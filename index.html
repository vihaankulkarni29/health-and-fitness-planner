<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMR AI Engineer Roadmap Tracker</title>
    <!-- Tailwind CSS CDN - This is the magic that applies styles without local build -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for a modern look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for task manager */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1; /* Light gray for track */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e0; /* Gray for thumb */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a0aec0; /* Darker gray on hover */
        }
        /* Dark mode scrollbar */
        .dark .custom-scrollbar::-webkit-scrollbar-track {
            background: #374151; /* Darker gray for track in dark mode */
        }
        .dark .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4b5563; /* Even darker gray for thumb in dark mode */
        }
        .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* Lighter gray on hover in dark mode */
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 text-gray-900 dark:from-gray-900 dark:to-gray-800 dark:text-gray-100 p-4 sm:p-8">

    <header class="text-center mb-10">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-indigo-800 dark:text-indigo-400 mb-2">
            AMR AI Engineer Roadmap Tracker
        </h1>
        <p class="text-lg sm:text-xl text-gray-700 dark:text-gray-300">
            Your personalized path to mastering AI Engineering for Antimicrobial Resistance.
        </p>
        <p id="user-id-display" class="text-sm text-gray-500 dark:text-gray-400 mt-2 hidden">
            Your User ID: <span id="user-id-value" class="font-mono bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded-md"></span>
        </p>
    </header>

    <!-- Overall Progress Bar -->
    <div class="w-full max-w-4xl mx-auto mb-10 bg-white dark:bg-gray-700 rounded-full shadow-lg p-2">
        <div class="text-center text-sm font-semibold mb-2 text-gray-700 dark:text-gray-200">
            Overall Roadmap Progress: <span id="overall-progress-value">0.0</span>%
        </div>
        <div class="w-full bg-gray-200 rounded-full h-4 dark:bg-gray-600">
            <div id="overall-progress-bar" class="bg-indigo-500 h-4 rounded-full transition-all duration-500 ease-out" style="width: 0%;"></div>
        </div>
    </div>

    <div id="app-container" class="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-4 gap-8">
        <!-- Roadmap Phases will be rendered here -->
        <div id="roadmap-phases-container" class="lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-8"></div>

        <!-- Daily Task Manager -->
        <div id="daily-task-manager-container" class="lg:col-span-1">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 h-full flex flex-col">
                <h2 class="text-2xl font-bold text-indigo-700 dark:text-indigo-300 mb-4">Daily Task Manager</h2>
                <div class="mb-4 flex">
                    <input type="text" id="new-task-input" class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-l-md focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:text-gray-100" placeholder="Add a new daily task...">
                    <button id="add-task-button" class="bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-r-md transition-colors duration-200">
                        Add
                    </button>
                </div>
                <div id="daily-tasks-list" class="flex-1 overflow-y-auto pr-2 -mr-2 custom-scrollbar">
                    <!-- Daily tasks will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center mt-12 text-gray-500 dark:text-gray-400 text-sm">
        Built with ❤️ for your AI Engineering journey in Bioinformatics.
    </footer>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyDb_h2OARdoZLebDTEDqvGxqD9M0Nbi4j4",
          authDomain: "amr-roadmap-tracker.firebaseapp.com",
          projectId: "amr-roadmap-tracker",
          storageBucket: "amr-roadmap-tracker.firebasestorage.app",
          messagingSenderId: "516367673314",
          appId: "1:516367673314:web:4dfdbcc6dfada610bdbbbb",
          measurementId: "G-7CEFN5ZJEM"
        };

        // Initialize Firebase (will be done once the DOM is ready)
        let app;
        let db;
        let auth;
        let analytics;
        let currentUserId = null;
        let completedSteps = {};
        let dailyTasks = [];

        // Define the roadmap data structure (same as in React app)
        const roadmap = [
            {
                phase: "Phase 1: Pipeline Core & Data Foundation",
                duration: "July - August",
                items: [
                    {
                        id: "p1_d1_db_integration",
                        type: "Deliverable",
                        name: "`db_manager.py` fully integrated into `BLASTpHitHarvester` and `WildTypeAligner`.",
                        reason: "Establish a fully integrated, robust, and data-capturing core pipeline.",
                        subtasks: [
                            { id: "p1_d1_s1_blast_db_write", name: "Modify `BLASTpHitHarvester` to write to `Proteins` table.", next: "Identify exact points in `BLASTpHitHarvester` to call `db_manager.insert_protein_metadata`. Ensure all relevant fields are mapped correctly. Test with a small BLAST XML." },
                            { id: "p1_d1_s2_aligner_db_write", name: "Modify `WildTypeAligner` to write to `Alignments` table.", next: "Identify exact points in `WildTypeAligner` to call `db_manager.insert_alignment_data`. Ensure identity, similarity, gaps, score, and `needle_file_path` are captured. Test with a few protein alignments." },
                            { id: "p1_d1_s3_log_pipeline_runs", name: "Implement `PipelineRunLog` calls in all tools (BLASTpHitHarvester, WildTypeAligner, SubScan).", next: "Add `db_manager.log_pipeline_run` calls at the start and end of each script, updating status (STARTED, COMPLETED, FAILED). Pass the `run_id` to subsequent data insertions." },
                            { id: "p1_d1_s4_error_handling_db", name: "Add robust error handling for database operations.", next: "Implement `try-except` blocks around all `db_manager` calls. Log specific database errors to the console and potentially to the `PipelineRunLog`." }
                        ]
                    },
                    {
                        id: "p1_d2_subscan_integration",
                        type: "Deliverable",
                        name: "`SubScan` integrated to read `.needle` files and populate `Mutations` table.",
                        reason: "Crucial for capturing the core biological insights (mutation detection) and storing them for analysis.",
                        subtasks: [
                            { id: "p1_d2_s1_subscan_parse_needle", name: "Refine `SubScan` to accurately parse `EMBOSS`-style `.needle` files.", next: "Ensure `SubScan` can correctly extract wild-type, position, and mutant residues from the alignment blocks. Test with diverse `.needle` files." },
                            { id: "p1_d2_s2_subscan_db_write", name: "Modify `SubScan` to insert detected mutations into the `Mutations` table.", next: "Map parsed mutation data to the `Mutations` table schema. Link mutations to the correct `protein_accession` and `pipeline_run_id`." },
                            { id: "p1_d2_s3_flag_known_mutations", name: "Implement logic in `SubScan` to flag known mutations (T104A, H596N).", next: "Use the `KNOWN_MUTATIONS` dictionary (or similar config) to set `is_known_mutation = 1` for relevant entries. Verify flagging with test data." },
                            { id: "p1_d2_s4_subscan_logging", name: "Add `PipelineRunLog` calls for `SubScan` execution.", next: "Log `SubScan` runs (STARTED, COMPLETED, FAILED) to the database." }
                        ]
                    },
                    {
                        id: "p1_s1_sqlite_management",
                        type: "Skill Acquired",
                        name: "Advanced SQLite/MySQL/SQLAlchemy database management, inter-tool data flow design.",
                        reason: "Foundational for robust data handling in bioinformatics pipelines, ensuring data consistency and efficient retrieval.",
                        next: "Review best practices for database schema design and normalization. Consider indexing strategies for performance on large tables. Practice complex joins."
                    },
                    {
                        id: "p1_m1_data_storage_metric",
                        type: "Metric",
                        name: "$100\%$ of data from `BLASTpHitHarvester` and `WildTypeAligner` runs are stored in the DB. $100\%$ of mutations from `SubScan` are stored in the DB.",
                        reason: "Quantifiable measure of data integration success and pipeline functionality.",
                        next: "Develop simple Python scripts to verify data counts and relationships in the database (e.g., count rows in each table, check foreign key linkages, ensure no missing data)."
                    },
                    {
                        id: "p1_da1_db_query_script",
                        type: "Data Analysis Deliverable",
                        name: "Enhanced mutation analysis script (Python) to query the SQLite/MySQL DB directly.",
                        reason: "Enables direct reporting from the integrated database, moving away from file-based analysis, providing more dynamic and comprehensive insights.",
                        next: "Adapt existing analysis scripts to use `db_manager.py` for data retrieval instead of reading raw files. Test with various queries to ensure correct data extraction."
                    },
                    {
                        id: "p1_s2_sql_querying",
                        type: "Skill Acquired",
                        name: "SQL querying for data aggregation and reporting.",
                        reason: "Essential for extracting insights from structured biological data, allowing you to answer complex research questions efficiently.",
                        next: "Practice complex SQL queries involving joins, aggregations, and subqueries on your new database tables. Explore window functions for ranking/partitioning data."
                    },
                ]
            },
            {
                phase: "Phase 2: Pipeline Automation & Scalability",
                duration: "September - October",
                items: [
                    {
                        id: "p2_d1_orchestration",
                        type: "Deliverable",
                        name: "Pipeline orchestration with `Snakemake` or `Nextflow`.",
                        reason: "Automate the entire `BLASTpHitHarvester` -> `WildTypeAligner` -> `SubScan` workflow from a single command, handling dependencies and basic error recovery.",
                        subtasks: [
                            { id: "p2_d1_s1_choose_workflow_manager", name: "Choose between Snakemake and Nextflow.", next: "Research pros and cons of each for your specific needs (e.g., community, syntax, cloud integration). Start with tutorials for both to get a feel." },
                            { id: "p2_d1_s2_basic_workflow_script", name: "Create a basic workflow script (Snakefile/Nextflow script) for a simple two-step process.", next: "Define inputs, outputs, and rules/processes for two linked steps (e.g., `BLASTpHitHarvester` output as `WildTypeAligner` input). Test basic execution." },
                            { id: "p2_d1_s3_full_pipeline_workflow", name: "Extend the workflow script to include all pipeline steps.", next: "Integrate `BLASTpHitHarvester`, `WildTypeAligner`, and `SubScan` into a single, cohesive workflow. Define all dependencies and parameters." },
                            { id: "p2_d1_s4_error_recovery_workflow", name: "Implement basic error handling and retry mechanisms in the workflow.", next: "Configure the workflow manager to handle failures gracefully (e.g., `onerror` in Snakemake, `errorStrategy` in Nextflow). Test with a deliberately failing step." }
                        ]
                    },
                    {
                        id: "p2_d2_dockerization",
                        type: "Deliverable",
                        name: "Docker containers for each core tool.",
                        reason: "Ensure reproducible environments, eliminating 'works on my machine' issues and facilitating deployment across different systems.",
                        subtasks: [
                            { id: "p2_d2_s1_dockerfile_blast", name: "Write a `Dockerfile` for `BLASTpHitHarvester`.", next: "Define base image, copy necessary files, install dependencies (`biopython`), and set entrypoint/command. Test building and running the container." },
                            { id: "p2_d2_s2_dockerfile_aligner", name: "Write a `Dockerfile` for `WildTypeAligner`.", next: "Repeat for `WildTypeAligner`, ensuring all Biopython dependencies are included. Test execution within the container." },
                            { id: "p2_d2_s3_dockerfile_subscan", name: "Write a `Dockerfile` for `SubScan`.", next: "Repeat for `SubScan`, ensuring `pandas` and `openpyxl` are installed. Test containerized execution." },
                            { id: "p2_d2_s4_container_integration_workflow", name: "Integrate Docker containers into the workflow manager.", next: "Configure Snakemake/Nextflow to execute steps within their respective Docker containers. Test the full containerized pipeline run." }
                        ]
                    },
                    {
                        id: "p2_s1_workflow_docker",
                        type: "Skill Acquired",
                        name: "Workflow management systems (Snakemake/Nextflow), Dockerization fundamentals.",
                        reason: "Crucial for building production-grade bioinformatics pipelines, enabling efficient and reliable execution.",
                        next: "Explore advanced features of your chosen workflow manager (e.g., parallelization, cloud execution). Understand Docker volumes and networking for data persistence and inter-container communication."
                    },
                    {
                        id: "p2_da1_cooccurrence",
                        type: "Data Analysis Deliverable",
                        name: "Co-occurrence analysis of mutations.",
                        reason: "Identify pairs or groups of mutations that frequently appear together in the same isolate, revealing potential epistatic interactions or shared evolutionary paths.",
                        next: "Explore `pandas` functions for pivot tables and co-occurrence matrices. Research network visualization libraries like `networkx` and `matplotlib` for drawing graphs. Define what constitutes 'co-occurrence' (e.g., in the same gene, same isolate, same protein)."
                    },
                    {
                        id: "p2_da2_geographic_explore",
                        type: "Data Analysis Deliverable",
                        name: "Initial exploration of geographic distribution (if country data is available and re-integrated).",
                        reason: "Begin to visualize mutation prevalence on a map, providing epidemiological insights into AMR spread.",
                        next: "Research `Plotly` or `Folium` for interactive mapping in Python. Consider how to aggregate country data from your `Proteins` table and link it to mutation data."
                    },
                    {
                        id: "p2_s2_pandas_networkx",
                        type: "Skill Acquired",
                        name: "Advanced `pandas` for data reshaping, network analysis basics (`networkx` in Python).",
                        reason: "Essential for complex data transformations and relationship discovery within large biological datasets.",
                        next: "Work through tutorials on `networkx` and `pandas` advanced grouping/pivoting (`groupby`, `pivot_table`, `melt`). Apply these to your mutation and protein data."
                    },
                ]
            },
            {
                phase: "Phase 3: AI Integration & Deployment Readiness",
                duration: "November - December",
                items: [
                    {
                        id: "p3_ai1_first_ml_model",
                        type: "AI/ML Deliverable",
                        name: "First AI model for 'Impact Prediction' or 'Phenotype Prediction'.",
                        reason: "Introduce initial AI components to move beyond detection to prediction and prioritization of AMR, adding significant value to your pipeline.",
                        subtasks: [
                            { id: "p3_ai1_s1_data_acquisition", name: "Acquire or curate a suitable dataset for initial ML model (genotype-phenotype or mutation impact).", next: "Search public databases (e.g., NCBI, CARD, PATRIC) for *E. coli* isolates with both efflux pump gene sequences/mutations and corresponding antibiotic susceptibility data. Alternatively, define a clear criterion for 'mutation impact' based on existing knowledge." },
                            { id: "p3_ai1_s2_feature_engineering_ml", name: "Develop initial feature engineering strategies for mutations.", next: "Explore one-hot encoding of specific mutations, amino acid physicochemical properties (e.g., hydrophobicity, charge change), or position-based features. Use `Biopython` for sequence manipulation." },
                            { id: "p3_ai1_s3_train_simple_model", name: "Train a simple `scikit-learn` classification model (e.g., Logistic Regression, Random Forest).", next: "Implement a basic training pipeline: data loading, feature preparation, model instantiation, training, and evaluation (accuracy, F1-score, ROC-AUC). Start with a binary classification task (e.g., Resistant/Susceptible to one antibiotic)." },
                            { id: "p3_ai1_s4_model_evaluation_report", name: "Generate a basic evaluation report for the first ML model.", next: "Document model performance metrics, highlight limitations, and identify areas for improvement (e.g., need more data, better features)." }
                        ]
                    },
                    {
                        id: "p3_s1_ml_feature_eng",
                        type: "Skill Acquired",
                        name: "Supervised machine learning model training, feature engineering for biological data.",
                        reason: "Core skills for an AI Engineer in bioinformatics, enabling you to build predictive and analytical AI solutions.",
                        next: "Deepen your understanding of various model evaluation metrics (precision, recall, F1-score, ROC-AUC) and cross-validation techniques. Explore advanced feature encoding methods for biological sequences (e.g., embeddings, k-mer frequencies)."
                    },
                    {
                        id: "p3_pd1_github_org",
                        type: "Professional Development Deliverable",
                        name: "Cleaned and organized GitHub repositories.",
                        reason: "Essential for collaboration, version control, and effectively showcasing your work to potential collaborators or employers.",
                        next: "Create a clear, logical repository structure (e.g., `wildtype_amr_tracker` as main repo, with subfolders for `blast_hitharvester`, `wildtype_aligner`, `subscan`, `db_manager`, `workflow_scripts`, `ml_models`). Add comprehensive `README.md` files for each component, including installation, usage, and examples. Set up a `.gitignore`."
                    },
                    {
                        id: "p3_pd2_streamlit_gui",
                        type: "Professional Development Deliverable",
                        name: "Basic Streamlit / web GUI prototype for data visualization.",
                        reason: "Provide an accessible interface for researchers without coding skills to interact with your pipeline's output, increasing its usability and impact.",
                        next: "Learn Streamlit basics (widgets, layout). Connect your Streamlit app to your SQLite database (`amr_surveillance.db`) to display mutation data and plots. Implement a simple input form for querying mutations or even uploading a single `.needle` file for on-the-fly analysis."
                    },
                    {
                        id: "p3_s2_streamlit_mlops",
                        type: "Skill Acquired",
                        name: "Streamlit for web app development, MLOps basics (e.g., understanding model serving concepts).",
                        reason: "Crucial for deploying and sharing AI-powered bioinformatics tools, bridging the gap between development and real-world application.",
                        next: "Explore cloud deployment options for Streamlit apps (e.g., Streamlit Community Cloud, Google Cloud Run). Understand concepts like API endpoints for your ML model and how to serve it for inference."
                    },
                ]
            },
            { // New Phase for Dr. Matange's Feedback
              phase: "Phase 4: Advanced AMR Insights & Comparative Genomics",
              duration: "Ongoing",
              items: [
                {
                  id: "p4_d1_mutation_variants",
                  type: "Data Analysis Deliverable",
                  name: "Quantify other `acrA`/`acrB` mutation variants (beyond knowns).",
                  reason: "Identify the full spectrum of observed mutations and their prevalence.",
                  next: "Query `Mutations` table for `acrA`/`acrB` where `is_known_mutation = 0`. Count unique `mutation_string`s."
                },
                {
                  id: "p4_d2_cooccurrence_acrAB",
                  type: "Data Analysis Deliverable",
                  name: "Analyze `acrA` and `acrB` mutation co-occurrence within isolates.",
                  reason: "Determine if `acrA` and `acrB` mutations occur simultaneously or independently in the same isolate.",
                  next: "Query `Mutations` table, group by `protein_accession` (or derived isolate ID). Check for presence of both `acrA` and `acrB` mutations per isolate."
                },
                {
                  id: "p4_d3_quantify_h596n",
                  type: "Data Analysis Deliverable",
                  name: "Quantify `acrB` proteins with `H596N` mutation.",
                  reason: "Track prevalence of a key high-interest mutation.",
                  next: "Query `Mutations` table: count unique `protein_accession` where `gene_name='acrB'` AND `mutation_string='H596N'`."
                },
                {
                  id: "p4_d4_quantify_t104a",
                  type: "Data Analysis Deliverable",
                  name: "Quantify `acrA` proteins with `T104A` mutation.",
                  reason: "Track prevalence of another key high-interest mutation.",
                  next: "Query `Mutations` table: count unique `protein_accession` where `gene_name='acrA'` AND `mutation_string='T104A'`."
                },
                {
                  id: "p4_d5_identify_dual_acrB_strains",
                  type: "Deliverable",
                  name: "Identify strains with 'dual AcrB' and characterize them.",
                  reason: "Understand the prevalence and genomic context of the specific 'dual AcrB' variant found in ECS34 and other species.",
                  subtasks: [
                    {
                      id: "p4_d5_s1_extract_ecs34_dual_acrB",
                      name: "Extract protein sequences for both `acrAB` operons from ECS34 genome.",
                      next: "Use `FastaAAExtractor` with ECS34 genome FASTA and manually identified coordinates for both operons."
                    },
                    {
                      id: "p4_d5_s2_align_ecs34_copies",
                      name: "Perform pairwise alignment of ECS34 `acrB_copy1` vs `acrB_copy2` (and `acrA` copies).",
                      next: "Use `WildTypeAligner`."
                    },
                    {
                      id: "p4_d5_s3_mut_analysis_ecs34_copies",
                      name: "Analyze mutations between ECS34 `acrB` copies using `SubScan`.",
                      next: "Run `SubScan` on alignment files from previous step."
                    },
                    {
                      id: "p4_d5_s4_acquire_genomes_salm_kleb",
                      name: "Acquire genomes of relevant *Salmonella*, *Klebsiella*, and *E. coli* isolates.",
                      next: "Use `NCBIGenomeExtractor` with BioSample/BioProject accession lists (e.g., from MDR strains)."
                    },
                    {
                      id: "p4_d5_s5_screen_genomes_for_dual_variant",
                      name: "Screen downloaded genomes for the 'dual AcrB' variant using local BLAST+.",
                      next: "Predict proteins from downloaded genomes (Prodigal/FastaAAExtractor). Create local BLAST DB. Run `blastp` with ECS34 'dual AcrB' sequence as query."
                    },
                    {
                      id: "p4_d5_s6_analyze_genomic_context",
                      name: "Analyze flanking regions of 'dual AcrB' in identified strains (IS elements, other genes).",
                      next: "Manual inspection in genome browser or programmatic search for specific elements."
                    },
                  ]
                },
                {
                  id: "p4_d6_serotype_cooccurrence",
                  type: "Data Analysis Deliverable",
                  name: "Analyze co-occurrence of mutations with serotype for dual `acrAB` strains.",
                  reason: "Investigate if 'dual AcrB' is linked to specific serotypes and if its presence correlates with specific `acrA`/`acrB` mutations.",
                  next: "Retrieve serotype info (from `NCBIGenomeExtractor` metadata). Query `Mutations` table for co-occurring mutations in 'dual AcrB' strains."
                },
                {
                  id: "p4_d7_ecoli_phylogeny",
                  type: "Data Analysis Deliverable",
                  name: "*E. coli* phylogeny to trace 'dual AcrB' lineage.",
                  reason: "Understand the evolutionary history and spread of the 'dual AcrB' variant.",
                  next: "Collect `acrB` sequences (ECS34 copies, other dual AcrB strains, ideal AcrB). Perform MSA (MAFFT/Clustal). Construct phylogenetic tree (IQ-TREE/RAxML). Visualize tree."
                },
                {
                  id: "p4_d8_compare_mg1655_isolates",
                  type: "Deliverable",
                  name: "Compare MG1655 genome with 4 natural isolate genomes.",
                  reason: "Establish a baseline for comparison and highlight differences in gene content/organization.",
                  next: "Select 4 diverse natural isolate genomes. Use comparative genomics tools (Mauve, ACT)."
                },
                {
                  id: "p4_d9_efflux_pump_counts",
                  type: "Data Analysis Deliverable",
                  name: "Count efflux pumps in all natural isolates.",
                  reason: "Quantify total efflux pump gene content across selected genomes.",
                  next: "For each isolate, predict genes (Prodigal/Prokka). Screen against efflux pump database (CARD subset). Develop `EffluxPumpCounter` script."
                },
                {
                  id: "p4_d10_detailed_ecs34_rnd_comp",
                  type: "Data Analysis Deliverable",
                  name: "Detailed comparison of MG1655 and ECS34 RND efflux pumps.",
                  reason: "Deep dive into the RND efflux pump systems of your key isolate.",
                  next: "Extract RND gene sequences from MG1655/ECS34. Pairwise align (WildTypeAligner). Analyze mutations (SubScan). Map to functional domains (Pfam/InterProScan)."
                },
              ]
            },
            { // New Phase for Review Article
              phase: "Phase 5: Review Article Preparation",
              duration: "Ongoing",
              items: [
                {
                  id: "p5_d1_review_rnd_lit",
                  type: "Deliverable",
                  name: "Literature review of published RND efflux pump reviews.",
                  reason: "Understand current state of research, key findings, and major gaps for your review article.",
                  next: "Perform targeted literature searches on PubMed, Google Scholar for review articles on RND efflux pumps in Gram-negative bacteria, *E. coli*."
                },
                {
                  id: "p5_d2_summarize_reviews",
                  type: "Deliverable",
                  name: "Summarize key themes and findings from RND efflux pump reviews.",
                  reason: "Synthesize existing knowledge for your review article.",
                  next: "Read and summarize main points, mechanisms, and clinical relevance. Potentially use AI text summarization tools."
                },
                {
                  id: "p5_d3_focus_regulatory",
                  type: "Deliverable",
                  name: "Specify on writing about regulatory methods of `acrAB` and like operons.",
                  reason: "Develop a focused section on crucial regulatory mechanisms (`AcrR`, `MarR`, `hns`, `sdiA`, `soxS`, `ompR`).",
                  next: "Deep dive into literature on regulation of `acrAB` and homologous operons. Focus on how mutations in regulators lead to overexpression and resistance."
                },
              ]
            }
          ];

        // Firebase Initialization and Auth
        window.addEventListener('load', () => { // Use window.onload to ensure DOM is ready
            try {
                // Initialize Firebase app with the globally defined firebaseConfig
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Initialize Analytics if you want to use it
                analytics = getAnalytics(app);

                // No need for setFirebaseApp, setDb, setAuth as they are global vars now

                // Sign in function adjusted for your deployment
                const signIn = async () => {
                    try {
                        await signInAnonymously(auth); // Use global auth instance
                        console.log("Signed in anonymously.");
                        currentUserId = auth.currentUser.uid; // Set global currentUserId
                        document.getElementById('user-id-value').textContent = currentUserId;
                        document.getElementById('user-id-display').classList.remove('hidden');
                        loadProgressAndTasks(); // Load data after successful sign-in
                    } catch (e) {
                        console.error("Firebase authentication error during sign-in:", e);
                        document.getElementById('error-message').textContent = "Authentication failed. Please ensure Anonymous Authentication is enabled in your Firebase project's console.";
                        document.getElementById('error-message').classList.remove('hidden');
                        document.getElementById('loading-message').classList.add('hidden');
                    }
                };

                signIn();

            } catch (e) {
                console.error("Firebase initialization or service access error:", e);
                let errorMessage = "Failed to initialize Firebase or access services. ";
                if (e.code === 'auth/configuration-not-found') {
                    errorMessage += "Please ensure Anonymous Authentication is enabled in your Firebase project's console and your project ID in firebaseConfig matches your Firebase project.";
                } else if (e.code === 'auth/invalid-api-key') {
                    errorMessage += "Please check your Firebase API Key in firebaseConfig.";
                }
                document.getElementById('error-message').textContent = errorMessage;
                document.getElementById('error-message').classList.remove('hidden');
                document.getElementById('loading-message').classList.add('hidden');
            }
        });

        // Function to load progress and tasks from Firestore
        const loadProgressAndTasks = () => {
            if (!currentUserId || !db) {
                console.warn("Cannot load progress: User not authenticated or DB not initialized.");
                return;
            }

            const roadmapDocRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/progress`, 'roadmap_status');
            const dailyTasksDocRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');

            // Listen for roadmap progress
            onSnapshot(roadmapDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    completedSteps = docSnap.data().completedSteps || {};
                    console.log("Roadmap progress loaded from Firestore.");
                } else {
                    console.log("No existing roadmap progress found. Starting fresh.");
                    completedSteps = {};
                }
                renderRoadmap(); // Re-render roadmap after loading progress
                updateOverallProgress();
            }, (err) => {
                console.error("Error fetching real-time roadmap progress:", err);
                document.getElementById('error-message').textContent = "Failed to load roadmap progress. Please check console for details.";
                document.getElementById('error-message').classList.remove('hidden');
            });

            // Listen for daily tasks
            onSnapshot(dailyTasksDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    dailyTasks = docSnap.data().tasks || [];
                    console.log("Daily tasks loaded from Firestore.");
                } else {
                    console.log("No existing daily tasks found. Starting fresh.");
                    dailyTasks = [];
                }
                renderDailyTasks(); // Re-render daily tasks after loading
                document.getElementById('loading-message').classList.add('hidden'); // Hide loading once data is loaded
            }, (err) => {
                console.error("Error fetching real-time daily tasks:", err);
                document.getElementById('error-message').textContent = "Failed to load daily tasks. Please check console for details.";
                document.getElementById('error-message').classList.remove('hidden');
                document.getElementById('loading-message').classList.add('hidden');
            });
        };

        // Function to save progress to Firestore
        const saveProgress = async (itemId, isSubtask = false, parentId = null) => {
            if (!currentUserId || !db) {
                console.error("Not authenticated. Cannot save progress.");
                document.getElementById('error-message').textContent = "Not authenticated. Cannot save progress.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            let newCompletedSteps = { ...completedSteps };

            if (isSubtask && parentId) {
                newCompletedSteps[itemId] = !newCompletedSteps[itemId];
                const parentItem = roadmap.flatMap(phase => phase.items).find(item => item.id === parentId);
                if (parentItem && parentItem.subtasks) {
                    const allSubtasksCompleted = parentItem.subtasks.every(sub => newCompletedSteps[sub.id]);
                    newCompletedSteps[parentId] = allSubtasksCompleted;
                }
            } else {
                newCompletedSteps[itemId] = !newCompletedSteps[itemId];
                const itemToToggle = roadmap.flatMap(phase => phase.items).find(item => item.id === itemId);
                if (itemToToggle && itemToToggle.subtasks && !newCompletedSteps[itemId]) {
                    itemToToggle.subtasks.forEach(sub => {
                        newCompletedSteps[sub.id] = false;
                    });
                }
            }
            completedSteps = newCompletedSteps; // Update global state
            renderRoadmap(); // Re-render UI immediately
            updateOverallProgress();

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/progress`, 'roadmap_status');
                await setDoc(docRef, { completedSteps: completedSteps }, { merge: true });
                console.log(`Progress for ${itemId} saved.`);
            } catch (e) {
                console.error("Error saving roadmap progress:", e);
                document.getElementById('error-message').textContent = "Failed to save roadmap progress. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to add a daily task
        const handleAddDailyTask = async () => {
            const newTaskInput = document.getElementById('new-task-input');
            const taskText = newTaskInput.value.trim();
            if (!taskText) {
                return;
            }
            if (!currentUserId || !db) {
                document.getElementById('error-message').textContent = "Not authenticated. Cannot add task.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            const newTask = { id: Date.now().toString(), text: taskText, completed: false };
            dailyTasks = [...dailyTasks, newTask]; // Update global state
            renderDailyTasks(); // Re-render UI immediately
            newTaskInput.value = ''; // Clear input

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');
                await setDoc(docRef, { tasks: dailyTasks }, { merge: true });
                console.log("Daily task added.");
            } catch (e) {
                console.error("Error adding daily task:", e);
                document.getElementById('error-message').textContent = "Failed to add daily task. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to toggle a daily task's completion
        const handleToggleDailyTask = async (taskId) => {
            if (!currentUserId || !db) {
                document.getElementById('error-message').textContent = "Not authenticated. Cannot update task.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            dailyTasks = dailyTasks.map(task =>
                task.id === taskId ? { ...task, completed: !task.completed } : task
            );
            renderDailyTasks(); // Re-render UI immediately

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');
                await setDoc(docRef, { tasks: dailyTasks }, { merge: true });
                console.log("Daily task toggled.");
            } catch (e) {
                console.error("Error toggling daily task:", e);
                document.getElementById('error-message').textContent = "Failed to update daily task. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to delete a daily task
        const handleDeleteDailyTask = async (taskId) => {
            if (!currentUserId || !db) {
                document.getElementById('error-message').textContent = "Not authenticated. Cannot delete task.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            dailyTasks = dailyTasks.filter(task => task.id !== taskId);
            renderDailyTasks(); // Re-render UI immediately

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');
                await setDoc(docRef, { tasks: dailyTasks }, { merge: true });
                console.log("Daily task deleted.");
            } catch (e) {
                console.error("Error deleting daily task:", e);
                document.getElementById('error-message').textContent = "Failed to delete daily task. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to calculate overall progress
        const updateOverallProgress = () => {
            let totalItems = 0;
            let completedItems = 0;
            roadmap.forEach(phase => {
                phase.items.forEach(item => {
                    if (item.subtasks && item.subtasks.length > 0) {
                        item.subtasks.forEach(subtask => {
                            totalItems++;
                            if (completedSteps[subtask.id]) {
                                completedItems++;
                            }
                        });
                    } else {
                        totalItems++;
                        if (completedSteps[item.id]) {
                            completedItems++;
                        }
                    }
                });
            });
            const overallProgress = totalItems > 0 ? (completedItems / totalItems) * 100 : 0;
            document.getElementById('overall-progress-value').textContent = overallProgress.toFixed(1);
            document.getElementById('overall-progress-bar').style.width = `${overallProgress}%`;
        };

        // --- Rendering Functions ---

        function renderRoadmap() {
            const container = document.getElementById('roadmap-phases-container');
            container.innerHTML = ''; // Clear existing content

            roadmap.forEach((phaseData, phaseIndex) => {
                const phaseDiv = document.createElement('div');
                phaseDiv.className = "bg-white dark:bg-gray-800 rounded-xl shadow-xl overflow-hidden transform transition-all duration-300 hover:scale-[1.01]";

                const phaseProgress = (() => {
                    let total = 0;
                    let completed = 0;
                    phaseData.items.forEach(item => {
                        if (item.subtasks && item.subtasks.length > 0) {
                            item.subtasks.forEach(subtask => {
                                total++;
                                if (completedSteps[subtask.id]) {
                                    completed++;
                                }
                            });
                        } else {
                            total++;
                            if (completedSteps[item.id]) {
                                completed++;
                            }
                        }
                    });
                    return total > 0 ? (completed / total) * 100 : 0;
                })();

                const isOpen = true; // Keep phases open by default for simplicity, or add state management

                phaseDiv.innerHTML = `
                    <div class="p-6 cursor-pointer flex justify-between items-center bg-indigo-600 dark:bg-indigo-900 text-white rounded-t-xl">
                        <div>
                            <h2 class="text-2xl font-bold">${phaseData.phase}</h2>
                            <p class="text-indigo-100 text-sm">${phaseData.duration}</p>
                        </div>
                        <div class="flex items-center">
                            <span class="text-lg font-semibold mr-3">${phaseProgress.toFixed(0)}%</span>
                            <svg class="w-6 h-6 transition-transform duration-300 ${isOpen ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </div>
                    <div class="p-6 space-y-6">
                        <!-- Items will be rendered here -->
                    </div>
                `;
                container.appendChild(phaseDiv);

                const itemsContainer = phaseDiv.querySelector('.space-y-6');
                phaseData.items.forEach(item => {
                    const isCompleted = completedSteps[item.id] || (item.subtasks && item.subtasks.every(sub => completedSteps[sub.id]));
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `p-4 rounded-lg border-2 transition-all duration-300 ${isCompleted ? 'bg-green-50 border-green-300 dark:bg-green-900 dark:border-green-700' : 'bg-gray-50 border-gray-200 dark:bg-gray-700 dark:border-gray-600'} hover:shadow-md`;
                    
                    itemDiv.innerHTML = `
                        <div class="flex items-start mb-3">
                            <input type="checkbox" id="item-${item.id}" class="form-checkbox h-5 w-5 text-indigo-600 rounded-md transition-colors duration-200 focus:ring-indigo-500 dark:bg-gray-600 dark:border-gray-500 dark:checked:bg-indigo-600 dark:checked:border-indigo-600" ${isCompleted ? 'checked' : ''} ${item.subtasks && item.subtasks.length > 0 ? 'disabled' : ''}>
                            <div class="ml-3 flex-1">
                                <h3 class="text-lg font-semibold ${isCompleted ? 'text-green-800 dark:text-green-300 line-through' : 'text-indigo-700 dark:text-indigo-300'}">
                                    ${item.name}
                                </h3>
                                <span class="inline-block px-2 py-0.5 text-xs font-medium rounded-full mt-1
                                    ${item.type === 'Deliverable' ? 'bg-blue-200 text-blue-800 dark:bg-blue-700 dark:text-blue-100' :
                                       item.type === 'Skill Acquired' ? 'bg-purple-200 text-purple-800 dark:bg-purple-700 dark:text-purple-100' :
                                       item.type === 'Metric' ? 'bg-yellow-200 text-yellow-800 dark:bg-yellow-700 dark:text-yellow-100' :
                                       item.type === 'Data Analysis Deliverable' ? 'bg-teal-200 text-teal-800 dark:bg-teal-700 dark:text-teal-100' :
                                       item.type === 'AI/ML Deliverable' ? 'bg-red-200 text-red-800 dark:bg-red-700 dark:text-red-100' :
                                       item.type === 'Professional Development Deliverable' ? 'bg-orange-200 text-orange-800 dark:bg-orange-700 dark:text-orange-100' :
                                       'bg-gray-200 text-gray-800 dark:bg-gray-600 dark:text-gray-200'
                                    }">
                                    ${item.type}
                                </span>
                            </div>
                        </div>
                        <div class="mt-2 text-sm text-gray-700 dark:text-gray-300">
                            <p class="font-medium text-gray-800 dark:text-gray-200">Reason:</p>
                            <p class="ml-2 pl-2 border-l-2 border-indigo-300 dark:border-indigo-600">${item.reason}</p>
                        </div>
                        ${item.subtasks && item.subtasks.length > 0 ? `
                            <div class="mt-4 border-t border-gray-200 dark:border-gray-700 pt-4">
                                <p class="font-medium text-gray-800 dark:text-gray-200 mb-2">Sub-tasks:</p>
                                <ul class="space-y-3">
                                    ${item.subtasks.map(subtask => {
                                        const isSubtaskCompleted = completedSteps[subtask.id];
                                        return `
                                            <li class="flex items-start">
                                                <input type="checkbox" id="subtask-${subtask.id}" class="form-checkbox h-4 w-4 text-purple-600 rounded-sm transition-colors duration-200 focus:ring-purple-500 dark:bg-gray-600 dark:border-gray-500 dark:checked:bg-purple-600 dark:checked:border-purple-600" ${isSubtaskCompleted ? 'checked' : ''}>
                                                <div class="ml-2 flex-1">
                                                    <span class="text-sm ${isSubtaskCompleted ? 'line-through text-gray-500 dark:text-gray-400' : 'text-gray-800 dark:text-gray-200'}">
                                                        ${subtask.name}
                                                    </span>
                                                    ${subtask.next ? `
                                                        <p class="text-xs text-gray-600 dark:text-gray-400 mt-1 ml-4 pl-2 border-l border-purple-200 dark:border-purple-500">
                                                            Next: ${subtask.next}
                                                        </p>
                                                    ` : ''}
                                                </div>
                                            </li>
                                        `;
                                    }).join('')}
                                </ul>
                            </div>
                        ` : `
                            <div class="mt-3 text-sm text-gray-700 dark:text-gray-300">
                                <p class="font-medium text-gray-800 dark:text-gray-200">Next Direction:</p>
                                <p class="ml-2 pl-2 border-l-2 border-purple-300 dark:border-purple-600">${item.next}</p>
                            </div>
                        `}
                    `;
                    itemsContainer.appendChild(itemDiv);

                    // Add event listener for main item checkbox
                    const itemCheckbox = itemDiv.querySelector(`#item-${item.id}`);
                    if (itemCheckbox) {
                        itemCheckbox.addEventListener('change', () => saveProgress(item.id));
                    }

                    // Add event listeners for subtask checkboxes
                    if (item.subtasks) {
                        item.subtasks.forEach(subtask => {
                            const subtaskCheckbox = itemDiv.querySelector(`#subtask-${subtask.id}`);
                            if (subtaskCheckbox) {
                                subtaskCheckbox.addEventListener('change', () => saveProgress(subtask.id, true, item.id));
                            }
                        });
                    }
                });
            });
        }

        function renderDailyTasks() {
            const container = document.getElementById('daily-tasks-list');
            container.innerHTML = ''; // Clear existing content

            if (dailyTasks.length === 0) {
                container.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-center mt-8">No daily tasks yet. Add one!</p>';
                return;
            }

            const ul = document.createElement('ul');
            ul.className = "space-y-3";

            dailyTasks.forEach(task => {
                const li = document.createElement('li');
                li.className = "flex items-center bg-gray-100 dark:bg-gray-700 p-3 rounded-lg shadow-sm";
                li.innerHTML = `
                    <input type="checkbox" id="task-${task.id}" class="form-checkbox h-5 w-5 text-green-600 rounded-md transition-colors duration-200 focus:ring-green-500 dark:bg-gray-600 dark:border-gray-500 dark:checked:bg-green-600 dark:checked:border-green-600" ${task.completed ? 'checked' : ''}>
                    <span class="ml-3 flex-1 text-gray-800 dark:text-gray-200 ${task.completed ? 'line-through text-gray-500 dark:text-gray-400' : ''}">
                        ${task.text}
                    </span>
                    <button id="delete-task-${task.id}" class="ml-4 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 transition-colors duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm2 5a1 1 0 011-1h4a1 1 0 110 2H9a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;
                ul.appendChild(li);

                // Add event listeners
                li.querySelector(`#task-${task.id}`).addEventListener('change', () => handleToggleDailyTask(task.id));
                li.querySelector(`#delete-task-${task.id}`).addEventListener('click', () => handleDeleteDailyTask(task.id));
            });
            container.appendChild(ul);
        }

        // --- Event Listeners for Daily Task Manager Input ---
        document.addEventListener('DOMContentLoaded', () => {
            const newTaskInput = document.getElementById('new-task-input');
            const addTaskButton = document.getElementById('add-task-button');

            if (addTaskButton) {
                addTaskButton.addEventListener('click', handleAddDailyTask);
            }
            if (newTaskInput) {
                newTaskInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        handleAddDailyTask();
                    }
                });
            }
        });
    </script>
</body>
</html>
```
I understand you're encountering a `SyntaxError` in the provided React code.

The error message `SyntaxError: invalid syntax` pointing to `header = [cell.text for cell in table.findall(".//Header/Cell")]` is happening because you have an incomplete JSX block (the `` and `` are internal markers that should not be part of the actual code). More specifically, the JSX is malformed because it's trying to render a React component (``) that isn't valid JSX.

The code you provided is a React component, and it seems like it's trying to include a `style jsx global` block, which is typically used with libraries like `styled-jsx` or Next.js, but not directly supported in a standard Create React App setup without additional configuration. Also, the HTML comments `<!-- ... -->` are not valid inside JSX without being wrapped in `{/* ... */}`.

I will now update the "Research Gap Finder" Canvas to fix these syntax errors and ensure the React component is correctly structured and runnable.


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMR AI Engineer Roadmap Tracker</title>
    <!-- Tailwind CSS CDN - This is the magic that applies styles without local build -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for a modern look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for task manager */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1; /* Light gray for track */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e0; /* Gray for thumb */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a0aec0; /* Darker gray on hover */
        }
        /* Dark mode scrollbar */
        .dark .custom-scrollbar::-webkit-scrollbar-track {
            background: #374151; /* Darker gray for track in dark mode */
        }
        .dark .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4b5563; /* Even darker gray for thumb in dark mode */
        }
        .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* Lighter gray on hover in dark mode */
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 text-gray-900 dark:from-gray-900 dark:to-gray-800 dark:text-gray-100 p-4 sm:p-8">

    <header class="text-center mb-10">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-indigo-800 dark:text-indigo-400 mb-2">
            AMR AI Engineer Roadmap Tracker
        </h1>
        <p class="text-lg sm:text-xl text-gray-700 dark:text-gray-300">
            Your personalized path to mastering AI Engineering for Antimicrobial Resistance.
        </p>
        <p id="user-id-display" class="text-sm text-gray-500 dark:text-gray-400 mt-2 hidden">
            Your User ID: <span id="user-id-value" class="font-mono bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded-md"></span>
        </p>
    </header>

    <!-- Overall Progress Bar -->
    <div class="w-full max-w-4xl mx-auto mb-10 bg-white dark:bg-gray-700 rounded-full shadow-lg p-2">
        <div class="text-center text-sm font-semibold mb-2 text-gray-700 dark:text-gray-200">
            Overall Roadmap Progress: <span id="overall-progress-value">0.0</span>%
        </div>
        <div class="w-full bg-gray-200 rounded-full h-4 dark:bg-gray-600">
            <div id="overall-progress-bar" class="bg-indigo-500 h-4 rounded-full transition-all duration-500 ease-out" style="width: 0%;"></div>
        </div>
    </div>

    <div id="app-container" class="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-4 gap-8">
        <!-- Roadmap Phases will be rendered here -->
        <div id="roadmap-phases-container" class="lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-8"></div>

        <!-- Daily Task Manager -->
        <div id="daily-task-manager-container" class="lg:col-span-1">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 h-full flex flex-col">
                <h2 class="text-2xl font-bold text-indigo-700 dark:text-indigo-300 mb-4">Daily Task Manager</h2>
                <div class="mb-4 flex">
                    <input type="text" id="new-task-input" class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-l-md focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:text-gray-100" placeholder="Add a new daily task...">
                    <button id="add-task-button" class="bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-r-md transition-colors duration-200">
                        Add
                    </button>
                </div>
                <div id="daily-tasks-list" class="flex-1 overflow-y-auto pr-2 -mr-2 custom-scrollbar">
                    <!-- Daily tasks will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center mt-12 text-gray-500 dark:text-gray-400 text-sm">
        Built with ❤️ for your AI Engineering journey in Bioinformatics.
    </footer>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyDb_h2OARdoZLebDTEDqvGxqD9M0Nbi4j4",
          authDomain: "amr-roadmap-tracker.firebaseapp.com",
          projectId: "amr-roadmap-tracker",
          storageBucket: "amr-roadmap-tracker.firebasestorage.app",
          messagingSenderId: "516367673314",
          appId: "1:516367673314:web:4dfdbcc6dfada610bdbbbb",
          measurementId: "G-7CEFN5ZJEM"
        };

        // Initialize Firebase (will be done once the DOM is ready)
        let app;
        let db;
        let auth;
        let analytics;
        let currentUserId = null;
        let completedSteps = {};
        let dailyTasks = [];

        // Define the roadmap data structure (same as in React app)
        const roadmap = [
            {
                phase: "Phase 1: Pipeline Core & Data Foundation",
                duration: "July - August",
                items: [
                    {
                        id: "p1_d1_db_integration",
                        type: "Deliverable",
                        name: "`db_manager.py` fully integrated into `BLASTpHitHarvester` and `WildTypeAligner`.",
                        reason: "Establish a fully integrated, robust, and data-capturing core pipeline.",
                        subtasks: [
                            { id: "p1_d1_s1_blast_db_write", name: "Modify `BLASTpHitHarvester` to write to `Proteins` table.", next: "Identify exact points in `BLASTpHitHarvester` to call `db_manager.insert_protein_metadata`. Ensure all relevant fields are mapped correctly. Test with a small BLAST XML." },
                            { id: "p1_d1_s2_aligner_db_write", name: "Modify `WildTypeAligner` to write to `Alignments` table.", next: "Identify exact points in `WildTypeAligner` to call `db_manager.insert_alignment_data`. Ensure identity, similarity, gaps, score, and `needle_file_path` are captured. Test with a few protein alignments." },
                            { id: "p1_d1_s3_log_pipeline_runs", name: "Implement `PipelineRunLog` calls in all tools (BLASTpHitHarvester, WildTypeAligner, SubScan).", next: "Add `db_manager.log_pipeline_run` calls at the start and end of each script, updating status (STARTED, COMPLETED, FAILED). Pass the `run_id` to subsequent data insertions." },
                            { id: "p1_d1_s4_error_handling_db", name: "Add robust error handling for database operations.", next: "Implement `try-except` blocks around all `db_manager` calls. Log specific database errors to the console and potentially to the `PipelineRunLog`." }
                        ]
                    },
                    {
                        id: "p1_d2_subscan_integration",
                        type: "Deliverable",
                        name: "`SubScan` integrated to read `.needle` files and populate `Mutations` table.",
                        reason: "Crucial for capturing the core biological insights (mutation detection) and storing them for analysis.",
                        subtasks: [
                            { id: "p1_d2_s1_subscan_parse_needle", name: "Refine `SubScan` to accurately parse `EMBOSS`-style `.needle` files.", next: "Ensure `SubScan` can correctly extract wild-type, position, and mutant residues from the alignment blocks. Test with diverse `.needle` files." },
                            { id: "p1_d2_s2_subscan_db_write", name: "Modify `SubScan` to insert detected mutations into the `Mutations` table.", next: "Map parsed mutation data to the `Mutations` table schema. Link mutations to the correct `protein_accession` and `pipeline_run_id`." },
                            { id: "p1_d2_s3_flag_known_mutations", name: "Implement logic in `SubScan` to flag known mutations (T104A, H596N).", next: "Use the `KNOWN_MUTATIONS` dictionary (or similar config) to set `is_known_mutation = 1` for relevant entries. Verify flagging with test data." },
                            { id: "p1_d2_s4_subscan_logging", name: "Add `PipelineRunLog` calls for `SubScan` execution.", next: "Log `SubScan` runs (STARTED, COMPLETED, FAILED) to the database." }
                        ]
                    },
                    {
                        id: "p1_s1_sqlite_management",
                        type: "Skill Acquired",
                        name: "Advanced SQLite/MySQL/SQLAlchemy database management, inter-tool data flow design.",
                        reason: "Foundational for robust data handling in bioinformatics pipelines, ensuring data consistency and efficient retrieval.",
                        next: "Review best practices for database schema design and normalization. Consider indexing strategies for performance on large tables. Practice complex joins."
                    },
                    {
                        id: "p1_m1_data_storage_metric",
                        type: "Metric",
                        name: "$100\%$ of data from `BLASTpHitHarvester` and `WildTypeAligner` runs are stored in the DB. $100\%$ of mutations from `SubScan` are stored in the DB.",
                        reason: "Quantifiable measure of data integration success and pipeline functionality.",
                        next: "Develop simple Python scripts to verify data counts and relationships in the database (e.g., count rows in each table, check foreign key linkages, ensure no missing data)."
                    },
                    {
                        id: "p1_da1_db_query_script",
                        type: "Data Analysis Deliverable",
                        name: "Enhanced mutation analysis script (Python) to query the SQLite/MySQL DB directly.",
                        reason: "Enables direct reporting from the integrated database, moving away from file-based analysis, providing more dynamic and comprehensive insights.",
                        next: "Adapt existing analysis scripts to use `db_manager.py` for data retrieval instead of reading raw files. Test with various queries to ensure correct data extraction."
                    },
                    {
                        id: "p1_s2_sql_querying",
                        type: "Skill Acquired",
                        name: "SQL querying for data aggregation and reporting.",
                        reason: "Essential for extracting insights from structured biological data, allowing you to answer complex research questions efficiently.",
                        next: "Practice complex SQL queries involving joins, aggregations, and subqueries on your new database tables. Explore window functions for ranking/partitioning data."
                    },
                ]
            },
            {
                phase: "Phase 2: Pipeline Automation & Scalability",
                duration: "September - October",
                items: [
                    {
                        id: "p2_d1_orchestration",
                        type: "Deliverable",
                        name: "Pipeline orchestration with `Snakemake` or `Nextflow`.",
                        reason: "Automate the entire `BLASTpHitHarvester` -> `WildTypeAligner` -> `SubScan` workflow from a single command, handling dependencies and basic error recovery.",
                        subtasks: [
                            { id: "p2_d1_s1_choose_workflow_manager", name: "Choose between Snakemake and Nextflow.", next: "Research pros and cons of each for your specific needs (e.g., community, syntax, cloud integration). Start with tutorials for both to get a feel." },
                            { id: "p2_d1_s2_basic_workflow_script", name: "Create a basic workflow script (Snakefile/Nextflow script) for a simple two-step process.", next: "Define inputs, outputs, and rules/processes for two linked steps (e.g., `BLASTpHitHarvester` output as `WildTypeAligner` input). Test basic execution." },
                            { id: "p2_d1_s3_full_pipeline_workflow", name: "Extend the workflow script to include all pipeline steps.", next: "Integrate `BLASTpHitHarvester`, `WildTypeAligner`, and `SubScan` into a single, cohesive workflow. Define all dependencies and parameters." },
                            { id: "p2_d1_s4_error_recovery_workflow", name: "Implement basic error handling and retry mechanisms in the workflow.", next: "Configure the workflow manager to handle failures gracefully (e.g., `onerror` in Snakemake, `errorStrategy` in Nextflow). Test with a deliberately failing step." }
                        ]
                    },
                    {
                        id: "p2_d2_dockerization",
                        type: "Deliverable",
                        name: "Docker containers for each core tool.",
                        reason: "Ensure reproducible environments, eliminating 'works on my machine' issues and facilitating deployment across different systems.",
                        subtasks: [
                            { id: "p2_d2_s1_dockerfile_blast", name: "Write a `Dockerfile` for `BLASTpHitHarvester`.", next: "Define base image, copy necessary files, install dependencies (`biopython`), and set entrypoint/command. Test building and running the container." },
                            { id: "p2_d2_s2_dockerfile_aligner", name: "Write a `Dockerfile` for `WildTypeAligner`.", next: "Repeat for `WildTypeAligner`, ensuring all Biopython dependencies are included. Test execution within the container." },
                            { id: "p2_d2_s3_dockerfile_subscan", name: "Write a `Dockerfile` for `SubScan`.", next: "Repeat for `SubScan`, ensuring `pandas` and `openpyxl` are installed. Test containerized execution." },
                            { id: "p2_d2_s4_container_integration_workflow", name: "Integrate Docker containers into the workflow manager.", next: "Configure Snakemake/Nextflow to execute steps within their respective Docker containers. Test the full containerized pipeline run." }
                        ]
                    },
                    {
                        id: "p2_s1_workflow_docker",
                        type: "Skill Acquired",
                        name: "Workflow management systems (Snakemake/Nextflow), Dockerization fundamentals.",
                        reason: "Crucial for building production-grade bioinformatics pipelines, enabling efficient and reliable execution.",
                        next: "Explore advanced features of your chosen workflow manager (e.g., parallelization, cloud execution). Understand Docker volumes and networking for data persistence and inter-container communication."
                    },
                    {
                        id: "p2_da1_cooccurrence",
                        type: "Data Analysis Deliverable",
                        name: "Co-occurrence analysis of mutations.",
                        reason: "Identify pairs or groups of mutations that frequently appear together in the same isolate, revealing potential epistatic interactions or shared evolutionary paths.",
                        next: "Explore `pandas` functions for pivot tables and co-occurrence matrices. Research network visualization libraries like `networkx` and `matplotlib` for drawing graphs. Define what constitutes 'co-occurrence' (e.g., in the same gene, same isolate, same protein)."
                    },
                    {
                        id: "p2_da2_geographic_explore",
                        type: "Data Analysis Deliverable",
                        name: "Initial exploration of geographic distribution (if country data is available and re-integrated).",
                        reason: "Begin to visualize mutation prevalence on a map, providing epidemiological insights into AMR spread.",
                        next: "Research `Plotly` or `Folium` for interactive mapping in Python. Consider how to aggregate country data from your `Proteins` table and link it to mutation data."
                    },
                    {
                        id: "p2_s2_pandas_networkx",
                        type: "Skill Acquired",
                        name: "Advanced `pandas` for data reshaping, network analysis basics (`networkx` in Python).",
                        reason: "Essential for complex data transformations and relationship discovery within large biological datasets.",
                        next: "Work through tutorials on `networkx` and `pandas` advanced grouping/pivoting (`groupby`, `pivot_table`, `melt`). Apply these to your mutation and protein data."
                    },
                ]
            },
            {
                phase: "Phase 3: AI Integration & Deployment Readiness",
                duration: "November - December",
                items: [
                    {
                        id: "p3_ai1_first_ml_model",
                        type: "AI/ML Deliverable",
                        name: "First AI model for 'Impact Prediction' or 'Phenotype Prediction'.",
                        reason: "Introduce initial AI components to move beyond detection to prediction and prioritization of AMR, adding significant value to your pipeline.",
                        subtasks: [
                            { id: "p3_ai1_s1_data_acquisition", name: "Acquire or curate a suitable dataset for initial ML model (genotype-phenotype or mutation impact).", next: "Search public databases (e.g., NCBI, CARD, PATRIC) for *E. coli* isolates with both efflux pump gene sequences/mutations and corresponding antibiotic susceptibility data. Alternatively, define a clear criterion for 'mutation impact' based on existing knowledge." },
                            { id: "p3_ai1_s2_feature_engineering_ml", name: "Develop initial feature engineering strategies for mutations.", next: "Explore one-hot encoding of specific mutations, amino acid physicochemical properties (e.g., hydrophobicity, charge change), or position-based features. Use `Biopython` for sequence manipulation." },
                            { id: "p3_ai1_s3_train_simple_model", name: "Train a simple `scikit-learn` classification model (e.g., Logistic Regression, Random Forest).", next: "Implement a basic training pipeline: data loading, feature preparation, model instantiation, training, and evaluation (accuracy, F1-score, ROC-AUC). Start with a binary classification task (e.g., Resistant/Susceptible to one antibiotic)." },
                            { id: "p3_ai1_s4_model_evaluation_report", name: "Generate a basic evaluation report for the first ML model.", next: "Document model performance metrics, highlight limitations, and identify areas for improvement (e.g., need more data, better features)." }
                        ]
                    },
                    {
                        id: "p3_s1_ml_feature_eng",
                        type: "Skill Acquired",
                        name: "Supervised machine learning model training, feature engineering for biological data.",
                        reason: "Core skills for an AI Engineer in bioinformatics, enabling you to build predictive and analytical AI solutions.",
                        next: "Deepen your understanding of various model evaluation metrics (precision, recall, F1-score, ROC-AUC) and cross-validation techniques. Explore advanced feature encoding methods for biological sequences (e.g., embeddings, k-mer frequencies)."
                    },
                    {
                        id: "p3_pd1_github_org",
                        type: "Professional Development Deliverable",
                        name: "Cleaned and organized GitHub repositories.",
                        reason: "Essential for collaboration, version control, and effectively showcasing your work to potential collaborators or employers.",
                        next: "Create a clear, logical repository structure (e.g., `wildtype_amr_tracker` as main repo, with subfolders for `blast_hitharvester`, `wildtype_aligner`, `subscan`, `db_manager`, `workflow_scripts`, `ml_models`). Add comprehensive `README.md` files for each component, including installation, usage, and examples. Set up a `.gitignore`."
                    },
                    {
                        id: "p3_pd2_streamlit_gui",
                        type: "Professional Development Deliverable",
                        name: "Basic Streamlit / web GUI prototype for data visualization.",
                        reason: "Provide an accessible interface for researchers without coding skills to interact with your pipeline's output, increasing its usability and impact.",
                        next: "Learn Streamlit basics (widgets, layout). Connect your Streamlit app to your SQLite database (`amr_surveillance.db`) to display mutation data and plots. Implement a simple input form for querying mutations or even uploading a single `.needle` file for on-the-fly analysis."
                    },
                    {
                        id: "p3_s2_streamlit_mlops",
                        type: "Skill Acquired",
                        name: "Streamlit for web app development, MLOps basics (e.g., understanding model serving concepts).",
                        reason: "Crucial for deploying and sharing AI-powered bioinformatics tools, bridging the gap between development and real-world application.",
                        next: "Explore cloud deployment options for Streamlit apps (e.g., Streamlit Community Cloud, Google Cloud Run). Understand concepts like API endpoints for your ML model and how to serve it for inference."
                    },
                ]
            },
            { // New Phase for Dr. Matange's Feedback
              phase: "Phase 4: Advanced AMR Insights & Comparative Genomics",
              duration: "Ongoing",
              items: [
                {
                  id: "p4_d1_mutation_variants",
                  type: "Data Analysis Deliverable",
                  name: "Quantify other `acrA`/`acrB` mutation variants (beyond knowns).",
                  reason: "Identify the full spectrum of observed mutations and their prevalence.",
                  next: "Query `Mutations` table for `acrA`/`acrB` where `is_known_mutation = 0`. Count unique `mutation_string`s."
                },
                {
                  id: "p4_d2_cooccurrence_acrAB",
                  type: "Data Analysis Deliverable",
                  name: "Analyze `acrA` and `acrB` mutation co-occurrence within isolates.",
                  reason: "Determine if `acrA` and `acrB` mutations occur simultaneously or independently in the same isolate.",
                  next: "Query `Mutations` table, group by `protein_accession` (or derived isolate ID). Check for presence of both `acrA` and `acrB` mutations per isolate."
                },
                {
                  id: "p4_d3_quantify_h596n",
                  type: "Data Analysis Deliverable",
                  name: "Quantify `acrB` proteins with `H596N` mutation.",
                  reason: "Track prevalence of a key high-interest mutation.",
                  next: "Query `Mutations` table: count unique `protein_accession` where `gene_name='acrB'` AND `mutation_string='H596N'`."
                },
                {
                  id: "p4_d4_quantify_t104a",
                  type: "Data Analysis Deliverable",
                  name: "Quantify `acrA` proteins with `T104A` mutation.",
                  reason: "Track prevalence of another key high-interest mutation.",
                  next: "Query `Mutations` table: count unique `protein_accession` where `gene_name='acrA'` AND `mutation_string='T104A'`."
                },
                {
                  id: "p4_d5_identify_dual_acrB_strains",
                  type: "Deliverable",
                  name: "Identify strains with 'dual AcrB' and characterize them.",
                  reason: "Understand the prevalence and genomic context of the specific 'dual AcrB' variant found in ECS34 and other species.",
                  subtasks: [
                    {
                      id: "p4_d5_s1_extract_ecs34_dual_acrB",
                      name: "Extract protein sequences for both `acrAB` operons from ECS34 genome.",
                      next: "Use `FastaAAExtractor` with ECS34 genome FASTA and manually identified coordinates for both operons."
                    },
                    {
                      id: "p4_d5_s2_align_ecs34_copies",
                      name: "Perform pairwise alignment of ECS34 `acrB_copy1` vs `acrB_copy2` (and `acrA` copies).",
                      next: "Use `WildTypeAligner`."
                    },
                    {
                      id: "p4_d5_s3_mut_analysis_ecs34_copies",
                      name: "Analyze mutations between ECS34 `acrB` copies using `SubScan`.",
                      next: "Run `SubScan` on alignment files from previous step."
                    },
                    {
                      id: "p4_d5_s4_acquire_genomes_salm_kleb",
                      name: "Acquire genomes of relevant *Salmonella*, *Klebsiella*, and *E. coli* isolates.",
                      next: "Use `NCBIGenomeExtractor` with BioSample/BioProject accession lists (e.g., from MDR strains)."
                    },
                    {
                      id: "p4_d5_s5_screen_genomes_for_dual_variant",
                      name: "Screen downloaded genomes for the 'dual AcrB' variant using local BLAST+.",
                      next: "Predict proteins from downloaded genomes (Prodigal/FastaAAExtractor). Create local BLAST DB. Run `blastp` with ECS34 'dual AcrB' sequence as query."
                    },
                    {
                      id: "p4_d5_s6_analyze_genomic_context",
                      name: "Analyze flanking regions of 'dual AcrB' in identified strains (IS elements, other genes).",
                      next: "Manual inspection in genome browser or programmatic search for specific elements."
                    },
                  ]
                },
                {
                  id: "p4_d6_serotype_cooccurrence",
                  type: "Data Analysis Deliverable",
                  name: "Analyze co-occurrence of mutations with serotype for dual `acrAB` strains.",
                  reason: "Investigate if 'dual AcrB' is linked to specific serotypes and if its presence correlates with specific `acrA`/`acrB` mutations.",
                  next: "Retrieve serotype info (from `NCBIGenomeExtractor` metadata). Query `Mutations` table for co-occurring mutations in 'dual AcrB' strains."
                },
                {
                  id: "p4_d7_ecoli_phylogeny",
                  type: "Data Analysis Deliverable",
                  name: "*E. coli* phylogeny to trace 'dual AcrB' lineage.",
                  reason: "Understand the evolutionary history and spread of the 'dual AcrB' variant.",
                  next: "Collect `acrB` sequences (ECS34 copies, other dual AcrB strains, ideal AcrB). Perform MSA (MAFFT/Clustal). Construct phylogenetic tree (IQ-TREE/RAxML). Visualize tree."
                },
                {
                  id: "p4_d8_compare_mg1655_isolates",
                  type: "Deliverable",
                  name: "Compare MG1655 genome with 4 natural isolate genomes.",
                  reason: "Establish a baseline for comparison and highlight differences in gene content/organization.",
                  next: "Select 4 diverse natural isolate genomes. Use comparative genomics tools (Mauve, ACT)."
                },
                {
                  id: "p4_d9_efflux_pump_counts",
                  type: "Data Analysis Deliverable",
                  name: "Count efflux pumps in all natural isolates.",
                  reason: "Quantify total efflux pump gene content across selected genomes.",
                  next: "For each isolate, predict genes (Prodigal/Prokka). Screen against efflux pump database (CARD subset). Develop `EffluxPumpCounter` script."
                },
                {
                  id: "p4_d10_detailed_ecs34_rnd_comp",
                  type: "Data Analysis Deliverable",
                  name: "Detailed comparison of MG1655 and ECS34 RND efflux pumps.",
                  reason: "Deep dive into the RND efflux pump systems of your key isolate.",
                  next: "Extract RND gene sequences from MG1655/ECS34. Pairwise align (WildTypeAligner). Analyze mutations (SubScan). Map to functional domains (Pfam/InterProScan)."
                },
              ]
            },
            { // New Phase for Review Article
              phase: "Phase 5: Review Article Preparation",
              duration: "Ongoing",
              items: [
                {
                  id: "p5_d1_review_rnd_lit",
                  type: "Deliverable",
                  name: "Literature review of published RND efflux pump reviews.",
                  reason: "Understand current state of research, key findings, and major gaps for your review article.",
                  next: "Perform targeted literature searches on PubMed, Google Scholar for review articles on RND efflux pumps in Gram-negative bacteria, *E. coli*."
                },
                {
                  id: "p5_d2_summarize_reviews",
                  type: "Deliverable",
                  name: "Summarize key themes and findings from RND efflux pump reviews.",
                  reason: "Synthesize existing knowledge for your review article.",
                  next: "Read and summarize main points, mechanisms, and clinical relevance. Potentially use AI text summarization tools."
                },
                {
                  id: "p5_d3_focus_regulatory",
                  type: "Deliverable",
                  name: "Specify on writing about regulatory methods of `acrAB` and like operons.",
                  reason: "Develop a focused section on crucial regulatory mechanisms (`AcrR`, `MarR`, `hns`, `sdiA`, `soxS`, `ompR`).",
                  next: "Deep dive into literature on regulation of `acrAB` and homologous operons. Focus on how mutations in regulators lead to overexpression and resistance."
                },
              ]
            }
          ];

        // Firebase Initialization and Auth
        window.addEventListener('load', () => { // Use window.onload to ensure DOM is ready
            try {
                // Initialize Firebase app with the globally defined firebaseConfig
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Initialize Analytics if you want to use it
                analytics = getAnalytics(app);

                // No need for setFirebaseApp, setDb, setAuth as they are global vars now

                // Sign in function adjusted for your deployment
                const signIn = async () => {
                    try {
                        await signInAnonymously(auth); // Use global auth instance
                        console.log("Signed in anonymously.");
                        currentUserId = auth.currentUser.uid; // Set global currentUserId
                        document.getElementById('user-id-value').textContent = currentUserId;
                        document.getElementById('user-id-display').classList.remove('hidden');
                        loadProgressAndTasks(); // Load data after successful sign-in
                    } catch (e) {
                        console.error("Firebase authentication error during sign-in:", e);
                        document.getElementById('error-message').textContent = "Authentication failed. Please ensure Anonymous Authentication is enabled in your Firebase project's console.";
                        document.getElementById('error-message').classList.remove('hidden');
                        document.getElementById('loading-message').classList.add('hidden');
                    }
                };

                signIn();

            } catch (e) {
                console.error("Firebase initialization or service access error:", e);
                let errorMessage = "Failed to initialize Firebase or access services. ";
                if (e.code === 'auth/configuration-not-found') {
                    errorMessage += "Please ensure Anonymous Authentication is enabled in your Firebase project's console and your project ID in firebaseConfig matches your Firebase project.";
                } else if (e.code === 'auth/invalid-api-key') {
                    errorMessage += "Please check your Firebase API Key in firebaseConfig.";
                }
                document.getElementById('error-message').textContent = errorMessage;
                document.getElementById('error-message').classList.remove('hidden');
                document.getElementById('loading-message').classList.add('hidden');
            }
        });

        // Function to load progress and tasks from Firestore
        const loadProgressAndTasks = () => {
            if (!currentUserId || !db) {
                console.warn("Cannot load progress: User not authenticated or DB not initialized.");
                return;
            }

            const roadmapDocRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/progress`, 'roadmap_status');
            const dailyTasksDocRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');

            // Listen for roadmap progress
            onSnapshot(roadmapDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    completedSteps = docSnap.data().completedSteps || {};
                    console.log("Roadmap progress loaded from Firestore.");
                } else {
                    console.log("No existing roadmap progress found. Starting fresh.");
                    completedSteps = {};
                }
                renderRoadmap(); // Re-render roadmap after loading progress
                updateOverallProgress();
            }, (err) => {
                console.error("Error fetching real-time roadmap progress:", err);
                document.getElementById('error-message').textContent = "Failed to load roadmap progress. Please check console for details.";
                document.getElementById('error-message').classList.remove('hidden');
            });

            // Listen for daily tasks
            onSnapshot(dailyTasksDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    dailyTasks = docSnap.data().tasks || [];
                    console.log("Daily tasks loaded from Firestore.");
                } else {
                    console.log("No existing daily tasks found. Starting fresh.");
                    dailyTasks = [];
                }
                renderDailyTasks(); // Re-render daily tasks after loading
                document.getElementById('loading-message').classList.add('hidden'); // Hide loading once data is loaded
            }, (err) => {
                console.error("Error fetching real-time daily tasks:", err);
                document.getElementById('error-message').textContent = "Failed to load daily tasks. Please check console for details.";
                document.getElementById('error-message').classList.remove('hidden');
                document.getElementById('loading-message').classList.add('hidden');
            });
        };

        // Function to save progress to Firestore
        const saveProgress = async (itemId, isSubtask = false, parentId = null) => {
            if (!currentUserId || !db) {
                console.error("Not authenticated. Cannot save progress.");
                document.getElementById('error-message').textContent = "Not authenticated. Cannot save progress.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            let newCompletedSteps = { ...completedSteps };

            if (isSubtask && parentId) {
                newCompletedSteps[itemId] = !newCompletedSteps[itemId];
                const parentItem = roadmap.flatMap(phase => phase.items).find(item => item.id === parentId);
                if (parentItem && parentItem.subtasks) {
                    const allSubtasksCompleted = parentItem.subtasks.every(sub => newCompletedSteps[sub.id]);
                    newCompletedSteps[parentId] = allSubtasksCompleted;
                }
            } else {
                newCompletedSteps[itemId] = !newCompletedSteps[itemId];
                const itemToToggle = roadmap.flatMap(phase => phase.items).find(item => item.id === itemId);
                if (itemToToggle && itemToToggle.subtasks && !newCompletedSteps[itemId]) {
                    itemToToggle.subtasks.forEach(sub => {
                        newCompletedSteps[sub.id] = false;
                    });
                }
            }
            completedSteps = newCompletedSteps; // Update global state
            renderRoadmap(); // Re-render UI immediately
            updateOverallProgress();

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/progress`, 'roadmap_status');
                await setDoc(docRef, { completedSteps: completedSteps }, { merge: true });
                console.log(`Progress for ${itemId} saved.`);
            } catch (e) {
                console.error("Error saving roadmap progress:", e);
                document.getElementById('error-message').textContent = "Failed to save roadmap progress. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to add a daily task
        const handleAddDailyTask = async () => {
            const newTaskInput = document.getElementById('new-task-input');
            const taskText = newTaskInput.value.trim();
            if (!taskText) {
                return;
            }
            if (!currentUserId || !db) {
                document.getElementById('error-message').textContent = "Not authenticated. Cannot add task.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            const newTask = { id: Date.now().toString(), text: taskText, completed: false };
            dailyTasks = [...dailyTasks, newTask]; // Update global state
            renderDailyTasks(); // Re-render UI immediately
            newTaskInput.value = ''; // Clear input

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');
                await setDoc(docRef, { tasks: dailyTasks }, { merge: true });
                console.log("Daily task added.");
            } catch (e) {
                console.error("Error adding daily task:", e);
                document.getElementById('error-message').textContent = "Failed to add daily task. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to toggle a daily task's completion
        const handleToggleDailyTask = async (taskId) => {
            if (!currentUserId || !db) {
                document.getElementById('error-message').textContent = "Not authenticated. Cannot update task.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            dailyTasks = dailyTasks.map(task =>
                task.id === taskId ? { ...task, completed: !task.completed } : task
            );
            renderDailyTasks(); // Re-render UI immediately

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');
                await setDoc(docRef, { tasks: dailyTasks }, { merge: true });
                console.log("Daily task toggled.");
            } catch (e) {
                console.error("Error toggling daily task:", e);
                document.getElementById('error-message').textContent = "Failed to update daily task. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to delete a daily task
        const handleDeleteDailyTask = async (taskId) => {
            if (!currentUserId || !db) {
                document.getElementById('error-message').textContent = "Not authenticated. Cannot delete task.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            dailyTasks = dailyTasks.filter(task => task.id !== taskId);
            renderDailyTasks(); // Re-render UI immediately

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');
                await setDoc(docRef, { tasks: dailyTasks }, { merge: true });
                console.log("Daily task deleted.");
            } catch (e) {
                console.error("Error deleting daily task:", e);
                document.getElementById('error-message').textContent = "Failed to delete daily task. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to calculate overall progress
        const updateOverallProgress = () => {
            let totalItems = 0;
            let completedItems = 0;
            roadmap.forEach(phase => {
                phase.items.forEach(item => {
                    if (item.subtasks && item.subtasks.length > 0) {
                        item.subtasks.forEach(subtask => {
                            totalItems++;
                            if (completedSteps[subtask.id]) {
                                completedItems++;
                            }
                        });
                    } else {
                        totalItems++;
                        if (completedSteps[item.id]) {
                            completedItems++;
                        }
                    }
                });
            });
            const overallProgress = totalItems > 0 ? (completedItems / totalItems) * 100 : 0;
            document.getElementById('overall-progress-value').textContent = overallProgress.toFixed(1);
            document.getElementById('overall-progress-bar').style.width = `${overallProgress}%`;
        };

        // --- Rendering Functions ---

        function renderRoadmap() {
            const container = document.getElementById('roadmap-phases-container');
            container.innerHTML = ''; // Clear existing content

            roadmap.forEach((phaseData, phaseIndex) => {
                const phaseDiv = document.createElement('div');
                phaseDiv.className = "bg-white dark:bg-gray-800 rounded-xl shadow-xl overflow-hidden transform transition-all duration-300 hover:scale-[1.01]";

                const phaseProgress = (() => {
                    let total = 0;
                    let completed = 0;
                    phaseData.items.forEach(item => {
                        if (item.subtasks && item.subtasks.length > 0) {
                            item.subtasks.forEach(subtask => {
                                total++;
                                if (completedSteps[subtask.id]) {
                                    completed++;
                                }
                            });
                        } else {
                            total++;
                            if (completedSteps[item.id]) {
                                completed++;
                            }
                        }
                    });
                    return total > 0 ? (completed / total) * 100 : 0;
                })();

                const isOpen = true; // Keep phases open by default for simplicity, or add state management

                phaseDiv.innerHTML = `
                    <div class="p-6 cursor-pointer flex justify-between items-center bg-indigo-600 dark:bg-indigo-900 text-white rounded-t-xl">
                        <div>
                            <h2 class="text-2xl font-bold">${phaseData.phase}</h2>
                            <p class="text-indigo-100 text-sm">${phaseData.duration}</p>
                        </div>
                        <div class="flex items-center">
                            <span class="text-lg font-semibold mr-3">${phaseProgress.toFixed(0)}%</span>
                            <svg class="w-6 h-6 transition-transform duration-300 ${isOpen ? 'rotate-180' : ''}" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                    </div>
                    <div class="p-6 space-y-6">
                        <!-- Items will be rendered here -->
                    </div>
                `;
                container.appendChild(phaseDiv);

                const itemsContainer = phaseDiv.querySelector('.space-y-6');
                phaseData.items.forEach(item => {
                    const isCompleted = completedSteps[item.id] || (item.subtasks && item.subtasks.every(sub => completedSteps[sub.id]));
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `p-4 rounded-lg border-2 transition-all duration-300 ${isCompleted ? 'bg-green-50 border-green-300 dark:bg-green-900 dark:border-green-700' : 'bg-gray-50 border-gray-200 dark:bg-gray-700 dark:border-gray-600'} hover:shadow-md`;
                    
                    itemDiv.innerHTML = `
                        <div class="flex items-start mb-3">
                            <input type="checkbox" id="item-${item.id}" class="form-checkbox h-5 w-5 text-indigo-600 rounded-md transition-colors duration-200 focus:ring-indigo-500 dark:bg-gray-600 dark:border-gray-500 dark:checked:bg-indigo-600 dark:checked:border-indigo-600" ${isCompleted ? 'checked' : ''} ${item.subtasks && item.subtasks.length > 0 ? 'disabled' : ''}>
                            <div class="ml-3 flex-1">
                                <h3 class="text-lg font-semibold ${isCompleted ? 'text-green-800 dark:text-green-300 line-through' : 'text-indigo-700 dark:text-indigo-300'}">
                                    ${item.name}
                                </h3>
                                <span class="inline-block px-2 py-0.5 text-xs font-medium rounded-full mt-1
                                    ${item.type === 'Deliverable' ? 'bg-blue-200 text-blue-800 dark:bg-blue-700 dark:text-blue-100' :
                                       item.type === 'Skill Acquired' ? 'bg-purple-200 text-purple-800 dark:bg-purple-700 dark:text-purple-100' :
                                       item.type === 'Metric' ? 'bg-yellow-200 text-yellow-800 dark:bg-yellow-700 dark:text-yellow-100' :
                                       item.type === 'Data Analysis Deliverable' ? 'bg-teal-200 text-teal-800 dark:bg-teal-700 dark:text-teal-100' :
                                       item.type === 'AI/ML Deliverable' ? 'bg-red-200 text-red-800 dark:bg-red-700 dark:text-red-100' :
                                       item.type === 'Professional Development Deliverable' ? 'bg-orange-200 text-orange-800 dark:bg-orange-700 dark:text-orange-100' :
                                       'bg-gray-200 text-gray-800 dark:bg-gray-600 dark:text-gray-200'
                                    }">
                                    ${item.type}
                                </span>
                            </div>
                        </div>
                        <div class="mt-2 text-sm text-gray-700 dark:text-gray-300">
                            <p class="font-medium text-gray-800 dark:text-gray-200">Reason:</p>
                            <p class="ml-2 pl-2 border-l-2 border-indigo-300 dark:border-indigo-600">${item.reason}</p>
                        </div>
                        ${item.subtasks && item.subtasks.length > 0 ? `
                            <div class="mt-4 border-t border-gray-200 dark:border-gray-700 pt-4">
                                <p class="font-medium text-gray-800 dark:text-gray-200 mb-2">Sub-tasks:</p>
                                <ul class="space-y-3">
                                    ${item.subtasks.map(subtask => {
                                        const isSubtaskCompleted = completedSteps[subtask.id];
                                        return `
                                            <li class="flex items-start">
                                                <input type="checkbox" id="subtask-${subtask.id}" class="form-checkbox h-4 w-4 text-purple-600 rounded-sm transition-colors duration-200 focus:ring-purple-500 dark:bg-gray-600 dark:border-gray-500 dark:checked:bg-purple-600 dark:checked:border-purple-600" ${isSubtaskCompleted ? 'checked' : ''}>
                                                <div class="ml-2 flex-1">
                                                    <span class="text-sm ${isSubtaskCompleted ? 'line-through text-gray-500 dark:text-gray-400' : 'text-gray-800 dark:text-gray-200'}">
                                                        ${subtask.name}
                                                    </span>
                                                    ${subtask.next ? `
                                                        <p class="text-xs text-gray-600 dark:text-gray-400 mt-1 ml-4 pl-2 border-l border-purple-200 dark:border-purple-500">
                                                            Next: ${subtask.next}
                                                        </p>
                                                    ` : ''}
                                                </div>
                                            </li>
                                        `;
                                    }).join('')}
                                </ul>
                            </div>
                        ` : `
                            <div class="mt-3 text-sm text-gray-700 dark:text-gray-300">
                                <p class="font-medium text-gray-800 dark:text-gray-200">Next Direction:</p>
                                <p class="ml-2 pl-2 border-l-2 border-purple-300 dark:border-purple-600">${item.next}</p>
                            </div>
                        `}
                    `;
                    itemsContainer.appendChild(itemDiv);

                    // Add event listener for main item checkbox
                    const itemCheckbox = itemDiv.querySelector(`#item-${item.id}`);
                    if (itemCheckbox) {
                        itemCheckbox.addEventListener('change', () => saveProgress(item.id));
                    }

                    // Add event listeners for subtask checkboxes
                    if (item.subtasks) {
                        item.subtasks.forEach(subtask => {
                            const subtaskCheckbox = itemDiv.querySelector(`#subtask-${subtask.id}`);
                            if (subtaskCheckbox) {
                                subtaskCheckbox.addEventListener('change', () => saveProgress(subtask.id, true, item.id));
                            }
                        });
                    }
                });
            });
        }

        function renderDailyTasks() {
            const container = document.getElementById('daily-tasks-list');
            container.innerHTML = ''; // Clear existing content

            if (dailyTasks.length === 0) {
                container.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-center mt-8">No daily tasks yet. Add one!</p>';
                return;
            }

            const ul = document.createElement('ul');
            ul.className = "space-y-3";

            dailyTasks.forEach(task => {
                const li = document.createElement('li');
                li.className = "flex items-center bg-gray-100 dark:bg-gray-700 p-3 rounded-lg shadow-sm";
                li.innerHTML = `
                    <input type="checkbox" id="task-${task.id}" class="form-checkbox h-5 w-5 text-green-600 rounded-md transition-colors duration-200 focus:ring-green-500 dark:bg-gray-600 dark:border-gray-500 dark:checked:bg-green-600 dark:checked:border-green-600" ${task.completed ? 'checked' : ''}>
                    <span class="ml-3 flex-1 text-gray-800 dark:text-gray-200 ${task.completed ? 'line-through text-gray-500 dark:text-gray-400' : ''}">
                        ${task.text}
                    </span>
                    <button id="delete-task-${task.id}" class="ml-4 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 transition-colors duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1zm2 5a1 1 0 011-1h4a1 1 0 110 2H9a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;
                ul.appendChild(li);

                // Add event listeners
                li.querySelector(`#task-${task.id}`).addEventListener('change', () => handleToggleDailyTask(task.id));
                li.querySelector(`#delete-task-${task.id}`).addEventListener('click', () => handleDeleteDailyTask(task.id));
            });
            container.appendChild(ul);
        }

        // --- Event Listeners for Daily Task Manager Input ---
        document.addEventListener('DOMContentLoaded', () => {
            const newTaskInput = document.getElementById('new-task-input');
            const addTaskButton = document.getElementById('add-task-button');

            if (addTaskButton) {
                addTaskButton.addEventListener('click', handleAddDailyTask);
            }
            if (newTaskInput) {
                newTaskInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        handleAddDailyTask();
                    }
                });
            }
        });
    </script>
</body>
</html>
```
You're looking to update the `AMR AI Engineer Roadmap Tracker` to incorporate Dr. Nishad Matange's feedback.

I will update the `amr-roadmap-tracker` Canvas to include the new tasks and sub-tasks from Dr. Matange's feedback. I'll integrate them into the existing phases where they fit best, ensuring each has a clear purpose and next step.

Here's the updated `index.html` file:


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMR AI Engineer Roadmap Tracker</title>
    <!-- Tailwind CSS CDN - This is the magic that applies styles without local build -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font for a modern look -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for task manager */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1; /* Light gray for track */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e0; /* Gray for thumb */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a0aec0; /* Darker gray on hover */
        }
        /* Dark mode scrollbar */
        .dark .custom-scrollbar::-webkit-scrollbar-track {
            background: #374151; /* Darker gray for track in dark mode */
        }
        .dark .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4b5563; /* Even darker gray for thumb in dark mode */
        }
        .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* Lighter gray on hover in dark mode */
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 text-gray-900 dark:from-gray-900 dark:to-gray-800 dark:text-gray-100 p-4 sm:p-8">

    <header class="text-center mb-10">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-indigo-800 dark:text-indigo-400 mb-2">
            AMR AI Engineer Roadmap Tracker
        </h1>
        <p class="text-lg sm:text-xl text-gray-700 dark:text-gray-300">
            Your personalized path to mastering AI Engineering for Antimicrobial Resistance.
        </p>
        <p id="user-id-display" class="text-sm text-gray-500 dark:text-gray-400 mt-2 hidden">
            Your User ID: <span id="user-id-value" class="font-mono bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded-md"></span>
        </p>
    </header>

    <!-- Overall Progress Bar -->
    <div class="w-full max-w-4xl mx-auto mb-10 bg-white dark:bg-gray-700 rounded-full shadow-lg p-2">
        <div class="text-center text-sm font-semibold mb-2 text-gray-700 dark:text-gray-200">
            Overall Roadmap Progress: <span id="overall-progress-value">0.0</span>%
        </div>
        <div class="w-full bg-gray-200 rounded-full h-4 dark:bg-gray-600">
            <div id="overall-progress-bar" class="bg-indigo-500 h-4 rounded-full transition-all duration-500 ease-out" style="width: 0%;"></div>
        </div>
    </div>

    <div id="app-container" class="max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-4 gap-8">
        <!-- Roadmap Phases will be rendered here -->
        <div id="roadmap-phases-container" class="lg:col-span-3 grid grid-cols-1 md:grid-cols-2 gap-8"></div>

        <!-- Daily Task Manager -->
        <div id="daily-task-manager-container" class="lg:col-span-1">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-xl p-6 h-full flex flex-col">
                <h2 class="text-2xl font-bold text-indigo-700 dark:text-indigo-300 mb-4">Daily Task Manager</h2>
                <div class="mb-4 flex">
                    <input type="text" id="new-task-input" class="flex-1 p-2 border border-gray-300 dark:border-gray-600 rounded-l-md focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:text-gray-100" placeholder="Add a new daily task...">
                    <button id="add-task-button" class="bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-r-md transition-colors duration-200">
                        Add
                    </button>
                </div>
                <div id="daily-tasks-list" class="flex-1 overflow-y-auto pr-2 -mr-2 custom-scrollbar">
                    <!-- Daily tasks will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center mt-12 text-gray-500 dark:text-gray-400 text-sm">
        Built with ❤️ for your AI Engineering journey in Bioinformatics.
    </footer>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyDb_h2OARdoZLebDTEDqvGxqD9M0Nbi4j4",
          authDomain: "amr-roadmap-tracker.firebaseapp.com",
          projectId: "amr-roadmap-tracker",
          storageBucket: "amr-roadmap-tracker.firebasestorage.app",
          messagingSenderId: "516367673314",
          appId: "1:516367673314:web:4dfdbcc6dfada610bdbbbb",
          measurementId: "G-7CEFN5ZJEM"
        };

        // Initialize Firebase (will be done once the DOM is ready)
        let app;
        let db;
        let auth;
        let analytics;
        let currentUserId = null;
        let completedSteps = {};
        let dailyTasks = [];

        // Define the roadmap data structure (same as in React app)
        const roadmap = [
            {
                phase: "Phase 1: Pipeline Core & Data Foundation",
                duration: "July - August",
                items: [
                    {
                        id: "p1_d1_db_integration",
                        type: "Deliverable",
                        name: "`db_manager.py` fully integrated into `BLASTpHitHarvester` and `WildTypeAligner`.",
                        reason: "Establish a fully integrated, robust, and data-capturing core pipeline.",
                        subtasks: [
                            { id: "p1_d1_s1_blast_db_write", name: "Modify `BLASTpHitHarvester` to write to `Proteins` table.", next: "Identify exact points in `BLASTpHitHarvester` to call `db_manager.insert_protein_metadata`. Ensure all relevant fields are mapped correctly. Test with a small BLAST XML." },
                            { id: "p1_d1_s2_aligner_db_write", name: "Modify `WildTypeAligner` to write to `Alignments` table.", next: "Identify exact points in `WildTypeAligner` to call `db_manager.insert_alignment_data`. Ensure identity, similarity, gaps, score, and `needle_file_path` are captured. Test with a few protein alignments." },
                            { id: "p1_d1_s3_log_pipeline_runs", name: "Implement `PipelineRunLog` calls in all tools (BLASTpHitHarvester, WildTypeAligner, SubScan).", next: "Add `db_manager.log_pipeline_run` calls at the start and end of each script, updating status (STARTED, COMPLETED, FAILED). Pass the `run_id` to subsequent data insertions." },
                            { id: "p1_d1_s4_error_handling_db", name: "Add robust error handling for database operations.", next: "Implement `try-except` blocks around all `db_manager` calls. Log specific database errors to the console and potentially to the `PipelineRunLog`." }
                        ]
                    },
                    {
                        id: "p1_d2_subscan_integration",
                        type: "Deliverable",
                        name: "`SubScan` integrated to read `.needle` files and populate `Mutations` table.",
                        reason: "Crucial for capturing the core biological insights (mutation detection) and storing them for analysis.",
                        subtasks: [
                            { id: "p1_d2_s1_subscan_parse_needle", name: "Refine `SubScan` to accurately parse `EMBOSS`-style `.needle` files.", next: "Ensure `SubScan` can correctly extract wild-type, position, and mutant residues from the alignment blocks. Test with diverse `.needle` files." },
                            { id: "p1_d2_s2_subscan_db_write", name: "Modify `SubScan` to insert detected mutations into the `Mutations` table.", next: "Map parsed mutation data to the `Mutations` table schema. Link mutations to the correct `protein_accession` and `pipeline_run_id`." },
                            { id: "p1_d2_s3_flag_known_mutations", name: "Implement logic in `SubScan` to flag known mutations (T104A, H596N).", next: "Use the `KNOWN_MUTATIONS` dictionary (or similar config) to set `is_known_mutation = 1` for relevant entries. Verify flagging with test data." },
                            { id: "p1_d2_s4_subscan_logging", name: "Add `PipelineRunLog` calls for `SubScan` execution.", next: "Log `SubScan` runs (STARTED, COMPLETED, FAILED) to the database." }
                        ]
                    },
                    {
                        id: "p1_s1_sqlite_management",
                        type: "Skill Acquired",
                        name: "Advanced SQLite/MySQL/SQLAlchemy database management, inter-tool data flow design.",
                        reason: "Foundational for robust data handling in bioinformatics pipelines, ensuring data consistency and efficient retrieval.",
                        next: "Review best practices for database schema design and normalization. Consider indexing strategies for performance on large tables. Practice complex joins."
                    },
                    {
                        id: "p1_m1_data_storage_metric",
                        type: "Metric",
                        name: "$100\%$ of data from `BLASTpHitHarvester` and `WildTypeAligner` runs are stored in the DB. $100\%$ of mutations from `SubScan` are stored in the DB.",
                        reason: "Quantifiable measure of data integration success and pipeline functionality.",
                        next: "Develop simple Python scripts to verify data counts and relationships in the database (e.g., count rows in each table, check foreign key linkages, ensure no missing data)."
                    },
                    {
                        id: "p1_da1_db_query_script",
                        type: "Data Analysis Deliverable",
                        name: "Enhanced mutation analysis script (Python) to query the SQLite/MySQL DB directly.",
                        reason: "Enables direct reporting from the integrated database, moving away from file-based analysis, providing more dynamic and comprehensive insights.",
                        next: "Adapt existing analysis scripts to use `db_manager.py` for data retrieval instead of reading raw files. Test with various queries to ensure correct data extraction."
                    },
                    {
                        id: "p1_s2_sql_querying",
                        type: "Skill Acquired",
                        name: "SQL querying for data aggregation and reporting.",
                        reason: "Essential for extracting insights from structured biological data, allowing you to answer complex research questions efficiently.",
                        next: "Practice complex SQL queries involving joins, aggregations, and subqueries on your new database tables. Explore window functions for ranking/partitioning data."
                    },
                ]
            },
            {
                phase: "Phase 2: Pipeline Automation & Scalability",
                duration: "September - October",
                items: [
                    {
                        id: "p2_d1_orchestration",
                        type: "Deliverable",
                        name: "Pipeline orchestration with `Snakemake` or `Nextflow`.",
                        reason: "Automate the entire `BLASTpHitHarvester` -> `WildTypeAligner` -> `SubScan` workflow from a single command, handling dependencies and basic error recovery.",
                        subtasks: [
                            { id: "p2_d1_s1_choose_workflow_manager", name: "Choose between Snakemake and Nextflow.", next: "Research pros and cons of each for your specific needs (e.g., community, syntax, cloud integration). Start with tutorials for both to get a feel." },
                            { id: "p2_d1_s2_basic_workflow_script", name: "Create a basic workflow script (Snakefile/Nextflow script) for a simple two-step process.", next: "Define inputs, outputs, and rules/processes for two linked steps (e.g., `BLASTpHitHarvester` output as `WildTypeAligner` input). Test basic execution." },
                            { id: "p2_d1_s3_full_pipeline_workflow", name: "Extend the workflow script to include all pipeline steps.", next: "Integrate `BLASTpHitHarvester`, `WildTypeAligner`, and `SubScan` into a single, cohesive workflow. Define all dependencies and parameters." },
                            { id: "p2_d1_s4_error_recovery_workflow", name: "Implement basic error handling and retry mechanisms in the workflow.", next: "Configure the workflow manager to handle failures gracefully (e.g., `onerror` in Snakemake, `errorStrategy` in Nextflow). Test with a deliberately failing step." }
                        ]
                    },
                    {
                        id: "p2_d2_dockerization",
                        type: "Deliverable",
                        name: "Docker containers for each core tool.",
                        reason: "Ensure reproducible environments, eliminating 'works on my machine' issues and facilitating deployment across different systems.",
                        subtasks: [
                            { id: "p2_d2_s1_dockerfile_blast", name: "Write a `Dockerfile` for `BLASTpHitHarvester`.", next: "Define base image, copy necessary files, install dependencies (`biopython`), and set entrypoint/command. Test building and running the container." },
                            { id: "p2_d2_s2_dockerfile_aligner", name: "Write a `Dockerfile` for `WildTypeAligner`.", next: "Repeat for `WildTypeAligner`, ensuring all Biopython dependencies are included. Test execution within the container." },
                            { id: "p2_d2_s3_dockerfile_subscan", name: "Write a `Dockerfile` for `SubScan`.", next: "Repeat for `SubScan`, ensuring `pandas` and `openpyxl` are installed. Test containerized execution." },
                            { id: "p2_d2_s4_container_integration_workflow", name: "Integrate Docker containers into the workflow manager.", next: "Configure Snakemake/Nextflow to execute steps within their respective Docker containers. Test the full containerized pipeline run." }
                        ]
                    },
                    {
                        id: "p2_s1_workflow_docker",
                        type: "Skill Acquired",
                        name: "Workflow management systems (Snakemake/Nextflow), Dockerization fundamentals.",
                        reason: "Crucial for building production-grade bioinformatics pipelines, enabling efficient and reliable execution.",
                        next: "Explore advanced features of your chosen workflow manager (e.g., parallelization, cloud execution). Understand Docker volumes and networking for data persistence and inter-container communication."
                    },
                    {
                        id: "p2_da1_cooccurrence",
                        type: "Data Analysis Deliverable",
                        name: "Co-occurrence analysis of mutations.",
                        reason: "Identify pairs or groups of mutations that frequently appear together in the same isolate, revealing potential epistatic interactions or shared evolutionary paths.",
                        next: "Explore `pandas` functions for pivot tables and co-occurrence matrices. Research network visualization libraries like `networkx` and `matplotlib` for drawing graphs. Define what constitutes 'co-occurrence' (e.g., in the same gene, same isolate, same protein)."
                    },
                    {
                        id: "p2_da2_geographic_explore",
                        type: "Data Analysis Deliverable",
                        name: "Initial exploration of geographic distribution (if country data is available and re-integrated).",
                        reason: "Begin to visualize mutation prevalence on a map, providing epidemiological insights into AMR spread.",
                        next: "Research `Plotly` or `Folium` for interactive mapping in Python. Consider how to aggregate country data from your `Proteins` table and link it to mutation data."
                    },
                    {
                        id: "p2_s2_pandas_networkx",
                        type: "Skill Acquired",
                        name: "Advanced `pandas` for data reshaping, network analysis basics (`networkx` in Python).",
                        reason: "Essential for complex data transformations and relationship discovery within large biological datasets.",
                        next: "Work through tutorials on `networkx` and `pandas` advanced grouping/pivoting (`groupby`, `pivot_table`, `melt`). Apply these to your mutation and protein data."
                    },
                ]
            },
            {
                phase: "Phase 3: AI Integration & Deployment Readiness",
                duration: "November - December",
                items: [
                    {
                        id: "p3_ai1_first_ml_model",
                        type: "AI/ML Deliverable",
                        name: "First AI model for 'Impact Prediction' or 'Phenotype Prediction'.",
                        reason: "Introduce initial AI components to move beyond detection to prediction and prioritization of AMR, adding significant value to your pipeline.",
                        subtasks: [
                            { id: "p3_ai1_s1_data_acquisition", name: "Acquire or curate a suitable dataset for initial ML model (genotype-phenotype or mutation impact).", next: "Search public databases (e.g., NCBI, CARD, PATRIC) for *E. coli* isolates with both efflux pump gene sequences/mutations and corresponding antibiotic susceptibility data. Alternatively, define a clear criterion for 'mutation impact' based on existing knowledge." },
                            { id: "p3_ai1_s2_feature_engineering_ml", name: "Develop initial feature engineering strategies for mutations.", next: "Explore one-hot encoding of specific mutations, amino acid physicochemical properties (e.g., hydrophobicity, charge change), or position-based features. Use `Biopython` for sequence manipulation." },
                            { id: "p3_ai1_s3_train_simple_model", name: "Train a simple `scikit-learn` classification model (e.g., Logistic Regression, Random Forest).", next: "Implement a basic training pipeline: data loading, feature preparation, model instantiation, training, and evaluation (accuracy, F1-score, ROC-AUC). Start with a binary classification task (e.g., Resistant/Susceptible to one antibiotic)." },
                            { id: "p3_ai1_s4_model_evaluation_report", name: "Generate a basic evaluation report for the first ML model.", next: "Document model performance metrics, highlight limitations, and identify areas for improvement (e.g., need more data, better features)." }
                        ]
                    },
                    {
                        id: "p3_s1_ml_feature_eng",
                        type: "Skill Acquired",
                        name: "Supervised machine learning model training, feature engineering for biological data.",
                        reason: "Core skills for an AI Engineer in bioinformatics, enabling you to build predictive and analytical AI solutions.",
                        next: "Deepen your understanding of various model evaluation metrics (precision, recall, F1-score, ROC-AUC) and cross-validation techniques. Explore advanced feature encoding methods for biological sequences (e.g., embeddings, k-mer frequencies)."
                    },
                    {
                        id: "p3_pd1_github_org",
                        type: "Professional Development Deliverable",
                        name: "Cleaned and organized GitHub repositories.",
                        reason: "Essential for collaboration, version control, and effectively showcasing your work to potential collaborators or employers.",
                        next: "Create a clear, logical repository structure (e.g., `wildtype_amr_tracker` as main repo, with subfolders for `blast_hitharvester`, `wildtype_aligner`, `subscan`, `db_manager`, `workflow_scripts`, `ml_models`). Add comprehensive `README.md` files for each component, including installation, usage, and examples. Set up a `.gitignore`."
                    },
                    {
                        id: "p3_pd2_streamlit_gui",
                        type: "Professional Development Deliverable",
                        name: "Basic Streamlit / web GUI prototype for data visualization.",
                        reason: "Provide an accessible interface for researchers without coding skills to interact with your pipeline's output, increasing its usability and impact.",
                        next: "Learn Streamlit basics (widgets, layout). Connect your Streamlit app to your SQLite database (`amr_surveillance.db`) to display mutation data and plots. Implement a simple input form for querying mutations or even uploading a single `.needle` file for on-the-fly analysis."
                    },
                    {
                        id: "p3_s2_streamlit_mlops",
                        type: "Skill Acquired",
                        name: "Streamlit for web app development, MLOps basics (e.g., understanding model serving concepts).",
                        reason: "Crucial for deploying and sharing AI-powered bioinformatics tools, bridging the gap between development and real-world application.",
                        next: "Explore cloud deployment options for Streamlit apps (e.g., Streamlit Community Cloud, Google Cloud Run). Understand concepts like API endpoints for your ML model and how to serve it for inference."
                    },
                ]
            },
            { // New Phase for Dr. Matange's Feedback
              phase: "Phase 4: Advanced AMR Insights & Comparative Genomics",
              duration: "Ongoing",
              items: [
                {
                  id: "p4_d1_mutation_variants",
                  type: "Data Analysis Deliverable",
                  name: "Quantify other `acrA`/`acrB` mutation variants (beyond knowns).",
                  reason: "Identify the full spectrum of observed mutations and their prevalence.",
                  next: "Query `Mutations` table for `acrA`/`acrB` where `is_known_mutation = 0`. Count unique `mutation_string`s."
                },
                {
                  id: "p4_d2_cooccurrence_acrAB",
                  type: "Data Analysis Deliverable",
                  name: "Analyze `acrA` and `acrB` mutation co-occurrence within isolates.",
                  reason: "Determine if `acrA` and `acrB` mutations occur simultaneously or independently in the same isolate.",
                  next: "Query `Mutations` table, group by `protein_accession` (or derived isolate ID). Check for presence of both `acrA` and `acrB` mutations per isolate."
                },
                {
                  id: "p4_d3_quantify_h596n",
                  type: "Data Analysis Deliverable",
                  name: "Quantify `acrB` proteins with `H596N` mutation.",
                  reason: "Track prevalence of a key high-interest mutation.",
                  next: "Query `Mutations` table: count unique `protein_accession` where `gene_name='acrB'` AND `mutation_string='H596N'`."
                },
                {
                  id: "p4_d4_quantify_t104a",
                  type: "Data Analysis Deliverable",
                  name: "Quantify `acrA` proteins with `T104A` mutation.",
                  reason: "Track prevalence of another key high-interest mutation.",
                  next: "Query `Mutations` table: count unique `protein_accession` where `gene_name='acrA'` AND `mutation_string='T104A'`."
                },
                {
                  id: "p4_d5_identify_dual_acrB_strains",
                  type: "Deliverable",
                  name: "Identify strains with 'dual AcrB' and characterize them.",
                  reason: "Understand the prevalence and genomic context of the specific 'dual AcrB' variant found in ECS34 and other species.",
                  subtasks: [
                    {
                      id: "p4_d5_s1_extract_ecs34_dual_acrB",
                      name: "Extract protein sequences for both `acrAB` operons from ECS34 genome.",
                      next: "Use `FastaAAExtractor` with ECS34 genome FASTA and manually identified coordinates for both operons."
                    },
                    {
                      id: "p4_d5_s2_align_ecs34_copies",
                      name: "Perform pairwise alignment of ECS34 `acrB_copy1` vs `acrB_copy2` (and `acrA` copies).",
                      next: "Use `WildTypeAligner`."
                    },
                    {
                      id: "p4_d5_s3_mut_analysis_ecs34_copies",
                      name: "Analyze mutations between ECS34 `acrB` copies using `SubScan`.",
                      next: "Run `SubScan` on alignment files from previous step."
                    },
                    {
                      id: "p4_d5_s4_acquire_genomes_salm_kleb",
                      name: "Acquire genomes of relevant *Salmonella*, *Klebsiella*, and *E. coli* isolates.",
                      next: "Use `NCBIGenomeExtractor` with BioSample/BioProject accession lists (e.g., from MDR strains)."
                    },
                    {
                      id: "p4_d5_s5_screen_genomes_for_dual_variant",
                      name: "Screen downloaded genomes for the 'dual AcrB' variant using local BLAST+.",
                      next: "Predict proteins from downloaded genomes (Prodigal/FastaAAExtractor). Create local BLAST DB. Run `blastp` with ECS34 'dual AcrB' sequence as query."
                    },
                    {
                      id: "p4_d5_s6_analyze_genomic_context",
                      name: "Analyze flanking regions of 'dual AcrB' in identified strains (IS elements, other genes).",
                      next: "Manual inspection in genome browser or programmatic search for specific elements."
                    },
                  ]
                },
                {
                  id: "p4_d6_serotype_cooccurrence",
                  type: "Data Analysis Deliverable",
                  name: "Analyze co-occurrence of mutations with serotype for dual `acrAB` strains.",
                  reason: "Investigate if 'dual AcrB' is linked to specific serotypes and if its presence correlates with specific `acrA`/`acrB` mutations.",
                  next: "Retrieve serotype info (from `NCBIGenomeExtractor` metadata). Query `Mutations` table for co-occurring mutations in 'dual AcrB' strains."
                },
                {
                  id: "p4_d7_ecoli_phylogeny",
                  type: "Data Analysis Deliverable",
                  name: "*E. coli* phylogeny to trace 'dual AcrB' lineage.",
                  reason: "Understand the evolutionary history and spread of the 'dual AcrB' variant.",
                  next: "Collect `acrB` sequences (ECS34 copies, other dual AcrB strains, ideal AcrB). Perform MSA (MAFFT/Clustal). Construct phylogenetic tree (IQ-TREE/RAxML). Visualize tree."
                },
                {
                  id: "p4_d8_compare_mg1655_isolates",
                  type: "Deliverable",
                  name: "Compare MG1655 genome with 4 natural isolate genomes.",
                  reason: "Establish a baseline for comparison and highlight differences in gene content/organization.",
                  next: "Select 4 diverse natural isolate genomes. Use comparative genomics tools (Mauve, ACT)."
                },
                {
                  id: "p4_d9_efflux_pump_counts",
                  type: "Data Analysis Deliverable",
                  name: "Count efflux pumps in all natural isolates.",
                  reason: "Quantify total efflux pump gene content across selected genomes.",
                  next: "For each isolate, predict genes (Prodigal/Prokka). Screen against efflux pump database (CARD subset). Develop `EffluxPumpCounter` script."
                },
                {
                  id: "p4_d10_detailed_ecs34_rnd_comp",
                  type: "Data Analysis Deliverable",
                  name: "Detailed comparison of MG1655 and ECS34 RND efflux pumps.",
                  reason: "Deep dive into the RND efflux pump systems of your key isolate.",
                  next: "Extract RND gene sequences from MG1655/ECS34. Pairwise align (WildTypeAligner). Analyze mutations (SubScan). Map to functional domains (Pfam/InterProScan)."
                },
              ]
            },
            { // New Phase for Review Article
              phase: "Phase 5: Review Article Preparation",
              duration: "Ongoing",
              items: [
                {
                  id: "p5_d1_review_rnd_lit",
                  type: "Deliverable",
                  name: "Literature review of published RND efflux pump reviews.",
                  reason: "Understand current state of research, key findings, and major gaps for your review article.",
                  next: "Perform targeted literature searches on PubMed, Google Scholar for review articles on RND efflux pumps in Gram-negative bacteria, *E. coli*."
                },
                {
                  id: "p5_d2_summarize_reviews",
                  type: "Deliverable",
                  name: "Summarize key themes and findings from RND efflux pump reviews.",
                  reason: "Synthesize existing knowledge for your review article.",
                  next: "Read and summarize main points, mechanisms, and clinical relevance. Potentially use AI text summarization tools."
                },
                {
                  id: "p5_d3_focus_regulatory",
                  type: "Deliverable",
                  name: "Specify on writing about regulatory methods of `acrAB` and like operons.",
                  reason: "Develop a focused section on crucial regulatory mechanisms (`AcrR`, `MarR`, `hns`, `sdiA`, `soxS`, `ompR`).",
                  next: "Deep dive into literature on regulation of `acrAB` and homologous operons. Focus on how mutations in regulators lead to overexpression and resistance."
                },
              ]
            }
          ];

        // Firebase Initialization and Auth
        window.addEventListener('load', () => { // Use window.onload to ensure DOM is ready
            try {
                // Initialize Firebase app with the globally defined firebaseConfig
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Initialize Analytics if you want to use it
                analytics = getAnalytics(app);

                // No need for setFirebaseApp, setDb, setAuth as they are global vars now

                // Sign in function adjusted for your deployment
                const signIn = async () => {
                    try {
                        await signInAnonymously(auth); // Use global auth instance
                        console.log("Signed in anonymously.");
                        currentUserId = auth.currentUser.uid; // Set global currentUserId
                        document.getElementById('user-id-value').textContent = currentUserId;
                        document.getElementById('user-id-display').classList.remove('hidden');
                        loadProgressAndTasks(); // Load data after successful sign-in
                    } catch (e) {
                        console.error("Firebase authentication error during sign-in:", e);
                        document.getElementById('error-message').textContent = "Authentication failed. Please ensure Anonymous Authentication is enabled in your Firebase project's console.";
                        document.getElementById('error-message').classList.remove('hidden');
                        document.getElementById('loading-message').classList.add('hidden');
                    }
                };

                signIn();

            } catch (e) {
                console.error("Firebase initialization or service access error:", e);
                let errorMessage = "Failed to initialize Firebase or access services. ";
                if (e.code === 'auth/configuration-not-found') {
                    errorMessage += "Please ensure Anonymous Authentication is enabled in your Firebase project's console and your project ID in firebaseConfig matches your Firebase project.";
                } else if (e.code === 'auth/invalid-api-key') {
                    errorMessage += "Please check your Firebase API Key in firebaseConfig.";
                }
                document.getElementById('error-message').textContent = errorMessage;
                document.getElementById('error-message').classList.remove('hidden');
                document.getElementById('loading-message').classList.add('hidden');
            }
        });

        // Function to load progress and tasks from Firestore
        const loadProgressAndTasks = () => {
            if (!currentUserId || !db) {
                console.warn("Cannot load progress: User not authenticated or DB not initialized.");
                return;
            }

            const roadmapDocRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/progress`, 'roadmap_status');
            const dailyTasksDocRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');

            // Listen for roadmap progress
            onSnapshot(roadmapDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    completedSteps = docSnap.data().completedSteps || {};
                    console.log("Roadmap progress loaded from Firestore.");
                } else {
                    console.log("No existing roadmap progress found. Starting fresh.");
                    completedSteps = {};
                }
                renderRoadmap(); // Re-render roadmap after loading progress
                updateOverallProgress();
            }, (err) => {
                console.error("Error fetching real-time roadmap progress:", err);
                document.getElementById('error-message').textContent = "Failed to load roadmap progress. Please check console for details.";
                document.getElementById('error-message').classList.remove('hidden');
            });

            // Listen for daily tasks
            onSnapshot(dailyTasksDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    dailyTasks = docSnap.data().tasks || [];
                    console.log("Daily tasks loaded from Firestore.");
                } else {
                    console.log("No existing daily tasks found. Starting fresh.");
                    dailyTasks = [];
                }
                renderDailyTasks(); // Re-render daily tasks after loading
                document.getElementById('loading-message').classList.add('hidden'); // Hide loading once data is loaded
            }, (err) => {
                console.error("Error fetching real-time daily tasks:", err);
                document.getElementById('error-message').textContent = "Failed to load daily tasks. Please check console for details.";
                document.getElementById('error-message').classList.remove('hidden');
                document.getElementById('loading-message').classList.add('hidden');
            });
        };

        // Function to save progress to Firestore
        const saveProgress = async (itemId, isSubtask = false, parentId = null) => {
            if (!currentUserId || !db) {
                console.error("Not authenticated. Cannot save progress.");
                document.getElementById('error-message').textContent = "Not authenticated. Cannot save progress.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            let newCompletedSteps = { ...completedSteps };

            if (isSubtask && parentId) {
                newCompletedSteps[itemId] = !newCompletedSteps[itemId];
                const parentItem = roadmap.flatMap(phase => phase.items).find(item => item.id === parentId);
                if (parentItem && parentItem.subtasks) {
                    const allSubtasksCompleted = parentItem.subtasks.every(sub => newCompletedSteps[sub.id]);
                    newCompletedSteps[parentId] = allSubtasksCompleted;
                }
            } else {
                newCompletedSteps[itemId] = !newCompletedSteps[itemId];
                const itemToToggle = roadmap.flatMap(phase => phase.items).find(item => item.id === itemId);
                if (itemToToggle && itemToToggle.subtasks && !newCompletedSteps[itemId]) {
                    itemToToggle.subtasks.forEach(sub => {
                        newCompletedSteps[sub.id] = false;
                    });
                }
            }
            completedSteps = newCompletedSteps; // Update global state
            renderRoadmap(); // Re-render UI immediately
            updateOverallProgress();

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/progress`, 'roadmap_status');
                await setDoc(docRef, { completedSteps: completedSteps }, { merge: true });
                console.log(`Progress for ${itemId} saved.`);
            } catch (e) {
                console.error("Error saving roadmap progress:", e);
                document.getElementById('error-message').textContent = "Failed to save roadmap progress. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to add a daily task
        const handleAddDailyTask = async () => {
            const newTaskInput = document.getElementById('new-task-input');
            const taskText = newTaskInput.value.trim();
            if (!taskText) {
                return;
            }
            if (!currentUserId || !db) {
                document.getElementById('error-message').textContent = "Not authenticated. Cannot add task.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            const newTask = { id: Date.now().toString(), text: taskText, completed: false };
            dailyTasks = [...dailyTasks, newTask]; // Update global state
            renderDailyTasks(); // Re-render UI immediately
            newTaskInput.value = ''; // Clear input

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');
                await setDoc(docRef, { tasks: dailyTasks }, { merge: true });
                console.log("Daily task added.");
            } catch (e) {
                console.error("Error adding daily task:", e);
                document.getElementById('error-message').textContent = "Failed to add daily task. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to toggle a daily task's completion
        const handleToggleDailyTask = async (taskId) => {
            if (!currentUserId || !db) {
                document.getElementById('error-message').textContent = "Not authenticated. Cannot update task.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            dailyTasks = dailyTasks.map(task =>
                task.id === taskId ? { ...task, completed: !task.completed } : task
            );
            renderDailyTasks(); // Re-render UI immediately

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');
                await setDoc(docRef, { tasks: dailyTasks }, { merge: true });
                console.log("Daily task toggled.");
            } catch (e) {
                console.error("Error toggling daily task:", e);
                document.getElementById('error-message').textContent = "Failed to update daily task. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to delete a daily task
        const handleDeleteDailyTask = async (taskId) => {
            if (!currentUserId || !db) {
                document.getElementById('error-message').textContent = "Not authenticated. Cannot delete task.";
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            dailyTasks = dailyTasks.filter(task => task.id !== taskId);
            renderDailyTasks(); // Re-render UI immediately

            try {
                const docRef = doc(db, `artifacts/${firebaseConfig.projectId}/users/${currentUserId}/daily_tasks`, 'tasks_list');
                await setDoc(docRef, { tasks: dailyTasks }, { merge: true });
                console.log("Daily task deleted.");
            } catch (e) {
                console.error("Error deleting daily task:", e);
                document.getElementById('error-message').textContent = "Failed to delete daily task. Please try again.";
                document.getElementById('error-message').classList.remove('hidden');
            }
        };

        // Function to calculate overall progress
        const updateOverallProgress = () => {
            let totalItems = 0;
            let completedItems = 0;
            roadmap.forEach(phase => {
                phase.items.forEach(item => {
                    if (item.subtasks && item.subtasks.length > 0) {
                        item.subtasks.forEach(subtask => {
                            totalItems++;
                            if (completedSteps[subtask.id]) {
                                completedItems++;
                            }
                        });
                    } else {
                        totalItems++;
                        if (completedSteps[item.id]) {
                            completedItems++;
                        }
                    }
                });
            });
            const overallProgress = totalItems > 0 ? (completedItems / totalItems) * 100 : 0;
            document.getElementById('overall-progress-value').textContent = overallProgress.toFixed(1);
            document.getElementById('overall-progress-bar').style.width = `${overallProgress}%`;
        };

        // --- Rendering Functions ---

        function renderRoadmap() {
            const container = document.getElementById('roadmap-phases-container');
            container.innerHTML = ''; // Clear existing content

            roadmap.forEach((phaseData, phaseIndex) => {
                const phaseDiv = document.createElement('div');
                phaseDiv.className = "bg-white dark:bg-gray-800 rounded-xl shadow-xl overflow-hidden transform transition-all duration-300 hover:scale-[1.01]";

                const phaseProgress = (() => {
                    let total = 0;
                    let completed = 0;
                    phaseData.items.forEach(item => {
                        if (item.subtasks && item.subtasks.length > 0) {
                            item.subtasks.forEach(subtask => {
                                total++;
                                if (completedSteps[subtask.id]) {
                                    completed++;
                                }
                            });
                        } else {
                            total++;
                            if (completedSteps[item.id]